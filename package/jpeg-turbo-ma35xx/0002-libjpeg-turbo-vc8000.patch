diff -Naur libjpeg-turbo-2.1.3/CMakeLists.txt libjpeg-turbo-2.1.3_new/CMakeLists.txt
--- libjpeg-turbo-2.1.3/CMakeLists.txt	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/CMakeLists.txt	2022-04-06 10:38:23.811459389 +0800
@@ -582,13 +582,28 @@
   add_subdirectory(java)
 endif()
 
+if(WITH_VC8000)
+  message(STATUS "With VC8000 support")
+  set(JPEG_SOURCES ${JPEG_SOURCES} vc8000_v4l2.c)
+endif()
+
 if(ENABLE_SHARED)
   add_subdirectory(sharedlib)
+  if(WITH_VC8000)
+    set_property(TARGET jpeg APPEND_STRING PROPERTY COMPILE_FLAGS
+	  " -DWITH_VC8000")
+  endif()
 endif()
 
 if(ENABLE_STATIC)
   add_library(jpeg-static STATIC ${JPEG_SOURCES} $<TARGET_OBJECTS:simd>
     ${SIMD_OBJS})
+
+  if(WITH_VC8000)
+    set_property(TARGET jpeg-static APPEND_STRING PROPERTY COMPILE_FLAGS
+	  " -DWITH_VC8000")
+  endif()
+
   if(NOT MSVC)
     set_target_properties(jpeg-static PROPERTIES OUTPUT_NAME jpeg)
   endif()
@@ -614,6 +629,10 @@
     add_library(turbojpeg SHARED ${TURBOJPEG_SOURCES})
     set_property(TARGET turbojpeg PROPERTY COMPILE_FLAGS
       "-DBMP_SUPPORTED -DPPM_SUPPORTED")
+    if(WITH_VC8000)
+      set_property(TARGET turbojpeg APPEND_STRING PROPERTY COMPILE_FLAGS
+        " -DWITH_VC8000")
+    endif()
     if(WIN32)
       set_target_properties(turbojpeg PROPERTIES DEFINE_SYMBOL DLLDEFINE)
     endif()
@@ -653,6 +672,10 @@
       rdppm.c wrbmp.c wrppm.c)
     set_property(TARGET turbojpeg-static PROPERTY COMPILE_FLAGS
       "-DBMP_SUPPORTED -DPPM_SUPPORTED")
+    if(WITH_VC8000)
+      set_property(TARGET turbojpeg-static APPEND_STRING PROPERTY COMPILE_FLAGS
+        " -DWITH_VC8000")
+    endif()
     if(NOT MSVC)
       set_target_properties(turbojpeg-static PROPERTIES OUTPUT_NAME turbojpeg)
     endif()
@@ -1516,6 +1539,8 @@
 install(FILES ${CMAKE_CURRENT_BINARY_DIR}/jconfig.h
   ${CMAKE_CURRENT_SOURCE_DIR}/jerror.h ${CMAKE_CURRENT_SOURCE_DIR}/jmorecfg.h
   ${CMAKE_CURRENT_SOURCE_DIR}/jpeglib.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/transupp.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/jpeglib_ext.h
   DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
 
 include(cmakescripts/BuildPackages.cmake)
diff -Naur libjpeg-turbo-2.1.3/jdapimin.c libjpeg-turbo-2.1.3_new/jdapimin.c
--- libjpeg-turbo-2.1.3/jdapimin.c	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jdapimin.c	2022-04-06 10:38:23.819459390 +0800
@@ -31,9 +31,86 @@
  * The error manager must already be set up (in case memory manager fails).
  */
 
+#ifdef WITH_VC8000
+
+static void 
+_jpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize, boolean enalbeHWDecode)
+{
+  int i;
+
+  /* Guard against version mismatches between library and caller. */
+  cinfo->mem = NULL;            /* so jpeg_destroy knows mem mgr not called */
+  if (version != JPEG_LIB_VERSION)
+    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
+  if (structsize != sizeof(struct jpeg_decompress_struct))
+    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,
+             (int)sizeof(struct jpeg_decompress_struct), (int)structsize);
+
+  /* For debugging purposes, we zero the whole master structure.
+   * But the application has already set the err pointer, and may have set
+   * client_data, so we have to save and restore those fields.
+   * Note: if application hasn't set client_data, tools like Purify may
+   * complain here.
+   */
+  {
+    struct jpeg_error_mgr *err = cinfo->err;
+    void *client_data = cinfo->client_data; /* ignore Purify complaint here */
+    memset(cinfo, 0, sizeof(struct jpeg_decompress_struct));
+    cinfo->err = err;
+    cinfo->client_data = client_data;
+  }
+  cinfo->is_decompressor = TRUE;
+
+  /* Initialize a memory manager instance for this object */
+  jinit_memory_mgr((j_common_ptr)cinfo);
+
+  /* Zero out pointers to permanent structures. */
+  cinfo->progress = NULL;
+  cinfo->src = NULL;
+
+  for (i = 0; i < NUM_QUANT_TBLS; i++)
+    cinfo->quant_tbl_ptrs[i] = NULL;
+
+  for (i = 0; i < NUM_HUFF_TBLS; i++) {
+    cinfo->dc_huff_tbl_ptrs[i] = NULL;
+    cinfo->ac_huff_tbl_ptrs[i] = NULL;
+  }
+
+  /* Initialize marker processor so application can override methods
+   * for COM, APPn markers before calling jpeg_read_header.
+   */
+  cinfo->marker_list = NULL;
+  jinit_marker_reader(cinfo);
+
+  /* And initialize the overall input controller. */
+  jinit_input_controller(cinfo);
+
+  /* OK, I'm ready */
+  cinfo->global_state = DSTATE_START;
+
+  /* The master struct is used to store extension parameters, so we allocate it
+   * here.
+   */
+  cinfo->master = (struct jpeg_decomp_master *)
+    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,
+                                sizeof(my_decomp_master));
+  memset(cinfo->master, 0, sizeof(my_decomp_master));
+
+  if(enalbeHWDecode == TRUE)
+    cinfo->master->bHWJpegDeocdeEnable = TRUE;
+  else
+    cinfo->master->bHWJpegDeocdeEnable = FALSE;
+}
+
+#endif
+
 GLOBAL(void)
 jpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)
 {
+#ifdef WITH_VC8000
+  _jpeg_CreateDecompress(cinfo, version, structsize, TRUE);
+#else
+
   int i;
 
   /* Guard against version mismatches between library and caller. */
@@ -93,8 +170,46 @@
     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,
                                 sizeof(my_decomp_master));
   memset(cinfo->master, 0, sizeof(my_decomp_master));
+
+#endif
+}
+
+#ifdef WITH_VC8000
+GLOBAL(void)
+jpeg_CreateDecompress_Ext(j_decompress_ptr cinfo, int version, size_t structsize, boolean enalbeHWDecode)
+{
+
+  if(enalbeHWDecode)
+  {
+	_jpeg_CreateDecompress(cinfo, version, structsize, TRUE);
+  }
+  else
+  {
+	_jpeg_CreateDecompress(cinfo, version, structsize, FALSE);
+  }
 }
 
+static void vc8000_destroy_decompress(j_decompress_ptr cinfo)
+{
+  if(cinfo->master->bHWJpegDecodeDone)
+    vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+
+  //close vc8000 v4l2 device for JPEG decoder
+  if(cinfo->master->bHWJpegCodecOpened)
+    vc8000_v4l2_close(&cinfo->master->sHWJpegVideo);
+
+  if(cinfo->master->pMemSrcBuf)
+  {
+    free(cinfo->master->pMemSrcBuf);
+    cinfo->master->pMemSrcBuf = NULL;
+  }
+
+  cinfo->master->bHWJpegCodecOpened = FALSE;  
+  cinfo->master->bHWJpegDecodeDone = FALSE;
+}
+
+#endif
+
 
 /*
  * Destruction of a JPEG decompression object
@@ -259,6 +374,59 @@
       cinfo->global_state != DSTATE_INHEADER)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
+#if 0 //def WITH_VC8000
+  if(cinfo->master->eJpegSrcType == eJPEG_SRC_UNKNOWN)
+  {
+    struct jpeg_source_mgr *src = cinfo->src;
+	uint32_t u32BitStreamLen = 0;
+	uint8_t *pu8BitStreamBufPtr = NULL;
+	uint8_t *pu8TempBufPtr = NULL;
+	boolean  bCopyDone = FALSE;
+	
+	if(src)
+	{
+		/* Initialize application's data source module */
+		(*cinfo->src->init_source)(cinfo);
+
+		while(src->fill_input_buffer(cinfo)){
+
+			if(src->bytes_in_buffer) {
+				pu8TempBufPtr = realloc(pu8BitStreamBufPtr, u32BitStreamLen + src->bytes_in_buffer + 100);
+				if(pu8TempBufPtr)
+					pu8BitStreamBufPtr = pu8TempBufPtr;
+				else
+					break;
+				memcpy(pu8BitStreamBufPtr + u32BitStreamLen, src->next_input_byte, src->bytes_in_buffer);
+				u32BitStreamLen += src->bytes_in_buffer;
+
+				src->bytes_in_buffer = 0;
+				
+				if((pu8BitStreamBufPtr[u32BitStreamLen - 2] == (JOCTET)0xFF) &&
+					(pu8BitStreamBufPtr[u32BitStreamLen - 1] == (JOCTET)JPEG_EOI))
+				{
+					bCopyDone = TRUE;
+					break;
+				}
+			}
+		}
+		
+		if(bCopyDone)
+		{
+			(*cinfo->src->term_source)(cinfo);
+			cinfo->src = NULL;
+			jpeg_mem_src(cinfo, pu8BitStreamBufPtr, u32BitStreamLen);
+			cinfo->master->pMemSrcBuf = pu8BitStreamBufPtr;
+		}
+		else
+		{
+			if(pu8BitStreamBufPtr)
+				free(pu8BitStreamBufPtr);
+		}
+    }
+  }
+
+#endif
+
   retcode = jpeg_consume_input(cinfo);
 
   switch (retcode) {
@@ -378,9 +546,28 @@
  * a suspending data source is used.
  */
 
+#ifdef WITH_VC8000
+static boolean vc8000_finish_decompress(j_decompress_ptr cinfo)
+{
+  if(cinfo->master->bHWJpegDecodeDone) {
+    vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+  }
+
+  cinfo->master->bHWJpegDecodeDone = FALSE;
+
+  return TRUE;
+}
+
+#endif
+
 GLOBAL(boolean)
 jpeg_finish_decompress(j_decompress_ptr cinfo)
 {
+#ifdef WITH_VC8000
+  vc8000_finish_decompress(cinfo);
+  vc8000_destroy_decompress(cinfo);
+#endif
+
   if ((cinfo->global_state == DSTATE_SCANNING ||
        cinfo->global_state == DSTATE_RAW_OK) && !cinfo->buffered_image) {
     /* Terminate final pass of non-buffered mode */
diff -Naur libjpeg-turbo-2.1.3/jdapistd.c libjpeg-turbo-2.1.3_new/jdapistd.c
--- libjpeg-turbo-2.1.3/jdapistd.c	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jdapistd.c	2022-04-06 10:38:23.819459390 +0800
@@ -41,9 +41,296 @@
  * a suspending data source is used.
  */
 
+#ifdef WITH_VC8000
+typedef enum
+{
+	eJPEG_SUBSAMPLING_411,
+	eJPEG_SUBSAMPLING_420,
+	eJPEG_SUBSAMPLING_422,
+	eJPEG_SUBSAMPLING_444,
+	eJPEG_SUBSAMPLING_UNKNOWN,
+}E_JPEG_SUBSAMPLING;
+
+static E_JPEG_SUBSAMPLING
+get_subsampling(j_decompress_ptr cinfo)
+{
+  if(cinfo->num_components != 3)
+    return eJPEG_SUBSAMPLING_UNKNOWN;
+    
+  if((cinfo->comp_info[0].h_samp_factor == 2) && (cinfo->comp_info[0].v_samp_factor == 2))
+    return eJPEG_SUBSAMPLING_420;
+    
+  if((cinfo->comp_info[0].h_samp_factor == 4) && (cinfo->comp_info[0].v_samp_factor == 1))
+    return eJPEG_SUBSAMPLING_411;
+    
+  if((cinfo->comp_info[0].h_samp_factor == 2) && (cinfo->comp_info[0].v_samp_factor == 1))
+    return eJPEG_SUBSAMPLING_422;
+
+  if((cinfo->comp_info[0].h_samp_factor == 1) && (cinfo->comp_info[0].v_samp_factor == 1))
+    return eJPEG_SUBSAMPLING_444;
+
+  return eJPEG_SUBSAMPLING_UNKNOWN;
+}
+
+#define SCALED(dimension, scalingFactor_num, scalingFactor_denom) \
+  ((dimension * scalingFactor_num + scalingFactor_denom - 1) / \
+   scalingFactor_denom)
+
+static void vc8000_CreateDecompress(j_decompress_ptr cinfo)
+{
+  //open vc8000 v4l2 device for JPEG decoder
+  if(vc8000_v4l2_open(&cinfo->master->sHWJpegVideo) == 0)
+    cinfo->master->bHWJpegCodecOpened = TRUE;
+  else
+    cinfo->master->bHWJpegCodecOpened = FALSE;  
+}
+
+#include <stdlib.h>
+#include <sys/time.h>
+#include <limits.h>
+
+static double getTimeSec(void)
+{
+  struct timeval tv;
+
+  if (gettimeofday(&tv, NULL) < 0)
+	return 0.0;
+  else 
+	return (double)(tv.tv_sec ) + ((double)(tv.tv_usec / 1000000.));
+}
+
+
+static int vc8000_start_decompress(j_decompress_ptr cinfo)
+{
+  int pixel_format;
+  int i32Ret;
+
+  cinfo->master->bHWJpegDecodeDone = FALSE;
+
+  if(cinfo->out_color_space == JCS_EXT_BGRA)
+  {
+    pixel_format = V4L2_PIX_FMT_ABGR32;
+  }
+  else if(cinfo->out_color_space == JCS_EXT_ARGB)
+  {
+    pixel_format = V4L2_PIX_FMT_ABGR32;
+  }
+  else if(cinfo->out_color_space == JCS_EXT_BGR)
+  {
+    pixel_format = V4L2_PIX_FMT_ABGR32;
+  }
+  else if(cinfo->out_color_space == JCS_RGB)
+  {
+    pixel_format = V4L2_PIX_FMT_ABGR32;
+  }
+  else if(cinfo->out_color_space == JCS_EXT_RGB)
+  {
+    pixel_format = V4L2_PIX_FMT_ABGR32;
+  }
+  else if(cinfo->out_color_space == JCS_RGB565)
+  {
+    pixel_format = V4L2_PIX_FMT_RGB565;
+  }
+  else if(cinfo->raw_data_out)
+  {
+    E_JPEG_SUBSAMPLING eSubsampling = get_subsampling(cinfo);
+    if(eSubsampling == eJPEG_SUBSAMPLING_420)
+      pixel_format = V4L2_PIX_FMT_NV12;  //Planar format
+    else if(eSubsampling == eJPEG_SUBSAMPLING_422)
+      pixel_format = V4L2_PIX_FMT_YUYV;  //packet format
+    else
+      return -1;    
+  }
+//  else if(cinfo->out_color_space == JCS_YCbCr)
+//  {
+//    pixel_format = V4L2_PIX_FMT_YUYV;
+//  }
+  else 
+	return -2;
+
+  jpeg_calc_output_dimensions(cinfo);
+
+  uint32_t decode_src_width;
+  uint32_t decode_src_height;
+  uint32_t estimate_output_width;
+  uint32_t estimate_output_height;
+  
+  //Align to VC8000 MCU dimension (16x16)
+  decode_src_width = jdiv_round_up(cinfo->image_width, 16) * 16;
+  decode_src_height = jdiv_round_up(cinfo->image_height, 16) * 16;
+  
+  estimate_output_width = SCALED(decode_src_width, cinfo->scale_num, cinfo->scale_denom);  
+  estimate_output_height = SCALED(decode_src_height, cinfo->scale_num, cinfo->scale_denom);  
+  
+  struct video_fb_info sFBInfo;
+  int iRotOP = PP_ROTATION_NONE;
+
+  sFBInfo.frame_buf_no = UINT_MAX;
+  
+  if(cinfo->master->bHWJpegDirectFBEnable)
+  {
+	sFBInfo.frame_buf_w = cinfo->master->sDirectFBParam.fb_width;
+	sFBInfo.frame_buf_h = cinfo->master->sDirectFBParam.fb_height;
+	sFBInfo.frame_buf_no = cinfo->master->sDirectFBParam.fb_no;
+	estimate_output_width = cinfo->master->sDirectFBParam.img_width;
+	estimate_output_height = cinfo->master->sDirectFBParam.img_height;	
+	iRotOP = cinfo->master->sDirectFBParam.rotation_op;
+  }
+  else
+  {
+	//output to memory buffer case. 
+	//output dimension is too small, maybe using software decoder is better.
+    if((estimate_output_width < 64) && (estimate_output_height < 64))
+		return -3;
+  }
+
+  if((iRotOP == PP_ROTATION_RIGHT_90) || (iRotOP == PP_ROTATION_LEFT_90))
+  {
+	uint32_t u32Temp;
+	u32Temp = decode_src_width;
+	decode_src_width = decode_src_height;
+	decode_src_height = u32Temp;
+  }
+
+  if(((decode_src_width > estimate_output_width) && (decode_src_height < estimate_output_height)) ||
+	((decode_src_width < estimate_output_width) && (decode_src_height > estimate_output_height)))
+  {
+	//the scale up/down of width and height must be consistent
+	return -4;
+  }
+
+  double dStartTime = getTimeSec();
+  i32Ret = vc8000_jpeg_prepare_decompress(
+			&cinfo->master->sHWJpegVideo,
+			cinfo->image_width,
+			cinfo->image_height,
+			estimate_output_width,
+			estimate_output_height,
+			cinfo->master->bHWJpegDirectFBEnable,
+			&sFBInfo,
+			cinfo->master->sDirectFBParam.img_pos_x,
+			cinfo->master->sDirectFBParam.img_pos_y,
+			iRotOP,
+			pixel_format);
+
+  if(i32Ret != 0) {
+//	printf("Not support by VC8000, output dimension width: %d, height: %d \n", estimate_output_width, estimate_output_height);
+    return -5;
+  }
+
+//  printf("vc8000_jpeg_prepare_decompress time %f sec\n", getTimeSec() - dStartTime);
+    
+  char *pchStreamBuf = NULL;
+  unsigned int u32StreamBufSize = 0;
+  unsigned int u32StreamLen = 0;
+  
+  u32StreamBufSize = vc8000_jpeg_get_bitstream_buffer(&cinfo->master->sHWJpegVideo, &pchStreamBuf);
+  
+  if(pchStreamBuf == NULL)
+  {
+	  //release resource
+	  vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+	  return -6;
+  }
+  
+  //fill bitstream to bitstream buffer
+  struct jpeg_source_mgr *src_mgr = cinfo->master->src_hw_jpeg;
+
+  if(cinfo->master->eJpegSrcType == eJPEG_SRC_MEM)
+  {
+    if(src_mgr->bytes_in_buffer > u32StreamBufSize)
+    {
+	  //release resource
+	  vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+	  return -7;
+	}
+    memcpy(pchStreamBuf, src_mgr->next_input_byte, src_mgr->bytes_in_buffer);
+	u32StreamLen = src_mgr->bytes_in_buffer; 
+  }
+  else if(cinfo->master->eJpegSrcType == eJPEG_SRC_FILE)
+  {
+    long u64CurFilePos = cinfo->master->seek_file_pos(cinfo, 0, SEEK_SET);
+
+    while(src_mgr->fill_input_buffer(cinfo) == TRUE)
+    {
+	  if((u32StreamLen + src_mgr->bytes_in_buffer) <= u32StreamBufSize)
+	  {
+		memcpy(pchStreamBuf + u32StreamLen, src_mgr->next_input_byte, src_mgr->bytes_in_buffer);
+	  }
+	  u32StreamLen += src_mgr->bytes_in_buffer;
+	}    
+    cinfo->master->seek_file_pos(cinfo, u64CurFilePos, SEEK_SET);
+
+	if(u32StreamLen > u32StreamBufSize)
+    {
+	  //release resource
+	  vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+	  return -8;
+	}
+  }
+  else
+  {
+    struct jpeg_source_mgr *src = cinfo->src;
+
+	if(src)
+	{
+      vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+      return -9;
+	}
+  }
+
+//  printf("fill bitstream time %f sec\n", getTimeSec() - dStartTime);
+
+  //inqueue bitstream buffer
+  vc8000_jpeg_inqueue_bitstream_buffer(&cinfo->master->sHWJpegVideo, pchStreamBuf, u32StreamLen);
+
+//  printf("vc8000_jpeg_inqueue_bitstream_buffer time %f sec\n", getTimeSec() - dStartTime);
+  //wait decode done
+  int i32DecBufIndex = 0;
+  
+  i32Ret = vc8000_jpeg_poll_decode_done(&cinfo->master->sHWJpegVideo, &i32DecBufIndex);
+  
+  if(i32Ret != 0)
+  {
+    //release resource
+    vc8000_jpeg_release_decompress(&cinfo->master->sHWJpegVideo);
+    return -10;
+  }
+
+//  printf("vc8000_jpeg_poll_decode_done time %f sec\n", getTimeSec() - dStartTime);
+
+  cinfo->master->pu8DecodedBuf = cinfo->master->sHWJpegVideo.cap_buf_addr[i32DecBufIndex][0];
+  cinfo->master->i32PixelFormat = pixel_format;
+  cinfo->master->u32DecodeImageWidth = cinfo->master->sHWJpegVideo.cap_w;
+  cinfo->master->u32DecodeImageHeight = cinfo->master->sHWJpegVideo.cap_h;
+  cinfo->master->bHWJpegDecodeDone = TRUE;
+
+  return 0;
+}
+
+
+#endif
+
 GLOBAL(boolean)
 jpeg_start_decompress(j_decompress_ptr cinfo)
 {
+#ifdef WITH_VC8000
+  int ret;
+
+  if(cinfo->master->bHWJpegDeocdeEnable == TRUE) {
+    vc8000_CreateDecompress(cinfo);
+  }
+
+  if(cinfo->master->bHWJpegCodecOpened) {
+	ret = vc8000_start_decompress(cinfo);
+    if(ret != 0)
+    {
+		printf("fallback to software decompress reason %d \n", ret);
+	}
+  }
+
+#endif
+
   if (cinfo->global_state == DSTATE_READY) {
     /* First call: initialize master control, select active modules */
     jinit_master_decompress(cinfo);
@@ -268,6 +555,302 @@
  * an oversize buffer (max_lines > scanlines remaining) is not an error.
  */
 
+#ifdef WITH_VC8000
+
+/**
+ * Pixel size (in bytes) for a given pixel format
+ */
+static const int csPixelSize[JPEG_NUMCS] = {
+  -1,	/*JCS_UNKNOWN*/ 
+  1,	/*JCS_GRAYSCALE*/
+  3,	/*JCS_RGB*/
+  2,	/*JCS_YCbCr*/
+  4,	/*JCS_CMYK*/
+  4,	/*JCS_YCCK*/
+  3,	/*JCS_EXT_RGB*/
+  4,	/*JCS_EXT_RGBX*/
+  3,	/*JCS_EXT_BGR*/
+  4,	/*JCS_EXT_BGRX*/
+  4,	/*JCS_EXT_XBGR*/
+  4,	/*JCS_EXT_XRGB*/
+  4,	/*JCS_EXT_RGBA*/
+  4,	/*JCS_EXT_BGRA*/
+  4,	/*JCS_EXT_ABGR*/
+  4,	/*JCS_EXT_ARGB*/
+  2,	/*JCS_RGB565*/
+};
+
+#if 1
+//from https://www.twblogs.net/a/5ef44dd90cb8aa7778837d67
+// size must multiple of 64
+static void _memcpy_fast(volatile void *dst, volatile void *src, int sz)
+{
+    asm volatile (
+        "NEONCopyPLD: \n"
+		"sub %[dst], %[dst], #64 \n"
+		"1: \n"
+		"ldnp q0, q1, [%[src]] \n"
+		"ldnp q2, q3, [%[src], #32] \n"
+		"add %[dst], %[dst], #64 \n"
+		"subs %[sz], %[sz], #64 \n"
+		"add %[src], %[src], #64 \n"
+		"stnp q0, q1, [%[dst]] \n"
+		"stnp q2, q3, [%[dst], #32] \n"
+		"b.gt 1b \n"
+		: [dst]"+r"(dst), [src]"+r"(src), [sz]"+r"(sz) : : "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "cc", "memory");
+}
+#else
+//from https://www.twblogs.net/a/5ef44dd90cb8aa7778837d67
+static void _memcpy_fast(volatile void *dst, volatile void *src, int sz)
+{
+    asm volatile (
+        "NEONCopyPLD: \n"
+		"sub %[src], %[src], #32 \n"
+		"sub %[dst], %[dst], #32 \n"
+		"1: \n"
+		"ldp q0, q1, [%[src], #32] \n"
+		"ldp q2, q3, [%[src], #64]! \n"
+		"subs %[sz], %[sz], #64 \n"
+		"stp q0, q1, [%[dst], #32] \n"
+		"stp q2, q3, [%[dst], #64]! \n"
+		"b.gt 1b \n"
+		: [dst]"+r"(dst), [src]"+r"(src), [sz]"+r"(sz) : : "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "cc", "memory");
+}
+#endif
+
+static JDIMENSION
+vc8000_read_scanlines(j_decompress_ptr cinfo, JSAMPARRAY scanlines,
+                    JDIMENSION max_lines)
+{
+  JDIMENSION row_ctr;
+  int i,j;
+  unsigned char *pu8DecodedSrc;
+  unsigned char *pu8RGBRow;
+  J_COLOR_SPACE eDecodedSrcCS;
+  int i32DecodedSrcPixelSize;
+  int i32OutputPixelSize;
+  unsigned int u32DecodedSrcRowBytes;
+  unsigned int u32RowBytes;
+
+  eDecodedSrcCS = cinfo->out_color_space;
+  
+  if(cinfo->master->i32PixelFormat == V4L2_PIX_FMT_ABGR32)
+    eDecodedSrcCS = JCS_EXT_ABGR;
+
+  i32DecodedSrcPixelSize = csPixelSize[eDecodedSrcCS];
+  i32OutputPixelSize = csPixelSize[cinfo->out_color_space];
+  
+  u32DecodedSrcRowBytes = cinfo->master->u32DecodeImageWidth * i32DecodedSrcPixelSize;
+  u32RowBytes = cinfo->output_width * i32OutputPixelSize;
+
+  row_ctr = max_lines;
+  
+  if((cinfo->output_scanline + row_ctr) >= cinfo->output_height)
+	row_ctr = cinfo->output_height - cinfo->output_scanline;
+
+  for(i = 0; i < row_ctr; i ++)
+  {
+    pu8DecodedSrc = cinfo->master->pu8DecodedBuf + ((cinfo->output_scanline + i) * u32DecodedSrcRowBytes);
+    pu8DecodedSrc += cinfo->master->first_iMCU_col * i32DecodedSrcPixelSize;
+
+    if(cinfo->master->i32PixelFormat == V4L2_PIX_FMT_ABGR32)
+    {
+	  if((cinfo->out_color_space == JCS_EXT_RGB) || (cinfo->out_color_space == JCS_RGB))
+	  {
+	    //copy BGRA data to RGB888
+	    pu8RGBRow = scanlines[i];
+#if 0
+		//1608x1072: ~863.1ms
+        for(j = 0; j < cinfo->output_width; j ++)
+        {
+		  //RGB pixel size 3 bytes, BGRA pixel size 4 bytes
+          *pu8RGBRow++ = pu8DecodedSrc[2];  
+          *pu8RGBRow++ = pu8DecodedSrc[1];
+          *pu8RGBRow++ = pu8DecodedSrc[0];
+		  pu8DecodedSrc += i32DecodedSrcPixelSize;
+	    }
+#else
+		//1608x1072: ~76.3ms
+		int u32RemainBytes = u32RowBytes & 11;
+		int u32FirstCopyBytes = u32RowBytes - u32RemainBytes;
+
+		register uint32_t u32Temp0;
+		register uint32_t u32Temp1;
+		register uint32_t u32Temp2;
+
+		if(u32FirstCopyBytes)
+		{
+			for(j = 0; j < u32FirstCopyBytes; j = j + 12)
+			{
+			  //BGR pixel size 3 bytes, BGRA pixel size 4 bytes
+			  u32Temp0 = (pu8DecodedSrc[2]) | (pu8DecodedSrc[1] << 8) | (pu8DecodedSrc[0] <<  16) | (pu8DecodedSrc[6] <<  24);  
+			  u32Temp1 = (pu8DecodedSrc[5]) | (pu8DecodedSrc[4] << 8) | (pu8DecodedSrc[10] <<  16) | (pu8DecodedSrc[9] <<  24);  
+			  u32Temp2 = (pu8DecodedSrc[8]) | (pu8DecodedSrc[14] << 8) | (pu8DecodedSrc[13] <<  16) | (pu8DecodedSrc[12] <<  24);  
+
+			  *(uint32_t *)pu8RGBRow = u32Temp0;
+			  *(uint32_t *)(pu8RGBRow + 4) = u32Temp1;
+			  *(uint32_t *)(pu8RGBRow + 8) = u32Temp2;           
+			  pu8RGBRow += 12;
+			  pu8DecodedSrc += 16; //i32DecodedSrcPixelSize;
+			}
+		}
+
+		//remain bytes ( < 12bytes) 
+		if(u32RemainBytes)
+		{
+			for(j = 0; j < u32RemainBytes; j = j + 3)
+			{
+			  *pu8RGBRow++ = pu8DecodedSrc[2];  
+			  *pu8RGBRow++ = pu8DecodedSrc[1];
+			  *pu8RGBRow++ = pu8DecodedSrc[0];
+			  pu8DecodedSrc += i32DecodedSrcPixelSize;
+			}
+		}
+
+#endif
+
+
+	  }
+	  else if(cinfo->out_color_space == JCS_EXT_BGR)
+	  {
+	     //copy BGRA data to BGR888
+	    pu8RGBRow = scanlines[i];
+
+#if 0		
+         for(j = 0; j < cinfo->output_width; j ++)
+         {
+		   //BGR pixel size 3 bytes, BGRA pixel size 4 bytes
+           *pu8RGBRow++ = pu8DecodedSrc[0];  
+           *pu8RGBRow++ = pu8DecodedSrc[1];
+           *pu8RGBRow++ = pu8DecodedSrc[2];
+		   pu8DecodedSrc += i32DecodedSrcPixelSize;
+	     }
+#else
+		int u32RemainBytes = u32RowBytes & 11;
+		int u32FirstCopyBytes = u32RowBytes - u32RemainBytes;
+
+		register uint32_t u32Temp0;
+		register uint32_t u32Temp1;
+		register uint32_t u32Temp2;
+
+		if(u32FirstCopyBytes)
+		{
+			for(j = 0; j < u32FirstCopyBytes; j = j + 12)
+			{
+			  //BGR pixel size 3 bytes, BGRA pixel size 4 bytes
+			  u32Temp0 = (pu8DecodedSrc[0]) | (pu8DecodedSrc[1] << 8) | (pu8DecodedSrc[2] <<  16) | (pu8DecodedSrc[4] <<  24);  
+			  u32Temp1 = (pu8DecodedSrc[5]) | (pu8DecodedSrc[6] << 8) | (pu8DecodedSrc[8] <<  16) | (pu8DecodedSrc[9] <<  24);  
+			  u32Temp2 = (pu8DecodedSrc[10]) | (pu8DecodedSrc[12] << 8) | (pu8DecodedSrc[13] <<  16) | (pu8DecodedSrc[14] <<  24);  
+
+			  *(uint32_t *)pu8RGBRow = u32Temp0;
+			  *(uint32_t *)(pu8RGBRow + 4) = u32Temp1;
+			  *(uint32_t *)(pu8RGBRow + 8) = u32Temp2;           
+			  pu8RGBRow += 12;
+			  pu8DecodedSrc += 16; //i32DecodedSrcPixelSize;
+			}
+		}
+
+		//remain bytes ( < 12bytes) 
+		if(u32RemainBytes)
+		{
+			for(j = 0; j < u32RemainBytes; j = j + 3)
+			{
+			  *pu8RGBRow++ = pu8DecodedSrc[0];  
+			  *pu8RGBRow++ = pu8DecodedSrc[1];
+			  *pu8RGBRow++ = pu8DecodedSrc[2];
+			  pu8DecodedSrc += i32DecodedSrcPixelSize;
+			}
+		}
+#endif
+
+	  }
+	  else if(cinfo->out_color_space == JCS_EXT_ARGB)
+	  {
+	    //copy BGRA data to ARGB
+	    pu8RGBRow = scanlines[i];
+
+#if 0		
+        for(j = 0; j < cinfo->output_width; j ++)
+        {
+		  //ARGB pixel size 4 bytes, BGRA pixel size 4 bytes
+          *pu8RGBRow++ = pu8DecodedSrc[3];  
+          *pu8RGBRow++ = pu8DecodedSrc[2];
+          *pu8RGBRow++ = pu8DecodedSrc[1];
+          *pu8RGBRow++ = pu8DecodedSrc[0];
+		  pu8DecodedSrc += i32DecodedSrcPixelSize;
+	    }
+#else
+		int u32RemainBytes = u32RowBytes & 15;
+		int u32FirstCopyBytes = u32RowBytes - u32RemainBytes;
+
+		register uint32_t u32Temp0;
+		register uint32_t u32Temp1;
+		register uint32_t u32Temp2;
+		register uint32_t u32Temp3;
+
+		if(u32FirstCopyBytes)
+		{
+			for(j = 0; j < u32FirstCopyBytes; j = j + 16)
+			{
+			  //ARGB pixel size 4 bytes, BGRA pixel size 4 bytes
+			  u32Temp0 = (pu8DecodedSrc[3]) | (pu8DecodedSrc[2] << 8) | (pu8DecodedSrc[1] <<  16) | (pu8DecodedSrc[0] <<  24);  
+			  u32Temp1 = (pu8DecodedSrc[7]) | (pu8DecodedSrc[6] << 8) | (pu8DecodedSrc[5] <<  16) | (pu8DecodedSrc[4] <<  24);  
+			  u32Temp2 = (pu8DecodedSrc[11]) | (pu8DecodedSrc[10] << 8) | (pu8DecodedSrc[9] <<  16) | (pu8DecodedSrc[8] <<  24);  
+			  u32Temp3 = (pu8DecodedSrc[15]) | (pu8DecodedSrc[14] << 8) | (pu8DecodedSrc[13] <<  16) | (pu8DecodedSrc[12] <<  24);  
+			  *(uint32_t *)pu8RGBRow = u32Temp0;
+			  *(uint32_t *)(pu8RGBRow + 4) = u32Temp1;
+			  *(uint32_t *)(pu8RGBRow + 8) = u32Temp2;
+			  *(uint32_t *)(pu8RGBRow + 12) = u32Temp3;    
+			  pu8RGBRow += 16;
+			  pu8DecodedSrc += 16; //i32DecodedSrcPixelSize;
+			}
+		}
+
+		//remain bytes ( < 16 bytes) 
+		if(u32RemainBytes)
+		{
+			for(j = 0; j < u32RemainBytes; j = j + 4)
+			{
+			  *pu8RGBRow++ = pu8DecodedSrc[3];  
+			  *pu8RGBRow++ = pu8DecodedSrc[2];
+			  *pu8RGBRow++ = pu8DecodedSrc[1];
+			  *pu8RGBRow++ = pu8DecodedSrc[0];
+			  pu8DecodedSrc += i32DecodedSrcPixelSize;
+			}
+		}
+#endif
+
+	  }	   
+	  else
+	  {
+
+#if 1
+		int u32RemainBytes = u32RowBytes & 63;
+		int u32FastCopyBytes = u32RowBytes - u32RemainBytes;
+
+	    pu8RGBRow = scanlines[i];
+		
+		if(u32FastCopyBytes)
+			_memcpy_fast(pu8RGBRow, pu8DecodedSrc, u32FastCopyBytes); //1608x1072: 57.6ms
+
+		if(u32RemainBytes)
+			memcpy(pu8RGBRow + u32FastCopyBytes, pu8DecodedSrc + u32FastCopyBytes, u32RemainBytes);
+#else
+		memcpy(scanlines[i], pu8DecodedSrc, u32RowBytes); //1608x1072: 97.3ms
+#endif
+	  }
+    }
+	else
+	{
+      memcpy(scanlines[i], pu8DecodedSrc, u32RowBytes);
+    }
+  }	
+
+  return row_ctr;
+}
+
+#endif
+
 GLOBAL(JDIMENSION)
 jpeg_read_scanlines(j_decompress_ptr cinfo, JSAMPARRAY scanlines,
                     JDIMENSION max_lines)
@@ -281,6 +864,22 @@
     return 0;
   }
 
+#ifdef WITH_VC8000
+  if(cinfo->master->bHWJpegDecodeDone)
+  {
+    row_ctr = 0;
+    double dStartTime = getTimeSec();
+    row_ctr = vc8000_read_scanlines(cinfo, scanlines, max_lines);
+    //printf("vc8000_read_scanlines time %f sec\n", getTimeSec() - dStartTime);
+
+    if(row_ctr > 0)
+    {
+      cinfo->output_scanline += row_ctr;
+      return row_ctr;
+    }
+  }
+#endif
+
   /* Call progress monitor hook if present */
   if (cinfo->progress != NULL) {
     cinfo->progress->pass_counter = (long)cinfo->output_scanline;
@@ -587,6 +1186,117 @@
  * Processes exactly one iMCU row per call, unless suspended.
  */
 
+#ifdef WITH_VC8000
+static JDIMENSION
+vc8000_read_raw_data(j_decompress_ptr cinfo, JSAMPIMAGE data,
+                   JDIMENSION max_lines)
+{
+  if((cinfo->master->i32PixelFormat != V4L2_PIX_FMT_YUYV) && (cinfo->master->i32PixelFormat != V4L2_PIX_FMT_NV12))
+    return 0;
+
+  int i, j;  
+
+  if((max_lines + cinfo->output_scanline) > cinfo->output_height)
+    max_lines = cinfo->output_height - cinfo->output_scanline;
+
+  JSAMPROW *y_comp = data[0];
+  JSAMPROW *u_comp = data[1];
+  JSAMPROW *v_comp = data[2];
+  
+  uint32_t y_pos = 0;
+  uint32_t u_pos = 0;
+  uint32_t v_pos = 0;
+
+  unsigned char *pu8YComp;
+  unsigned char *pu8UComp;
+  unsigned char *pu8VComp;
+
+
+  if(cinfo->master->i32PixelFormat == V4L2_PIX_FMT_YUYV)
+  {
+    unsigned char *pu8DecodedSrc;
+    unsigned int u32YUYVPixelSize = 2;
+    unsigned int u32RowBytes = cinfo->master->u32DecodeImageWidth * u32YUYVPixelSize;
+
+    for(j = 0; j < max_lines; j  ++)
+    {
+      pu8DecodedSrc = cinfo->master->pu8DecodedBuf + ((cinfo->output_scanline + j) * u32RowBytes);
+      pu8DecodedSrc += cinfo->master->first_iMCU_col * u32YUYVPixelSize;
+
+	  pu8YComp = y_comp[j];
+	  pu8UComp = u_comp[j];
+	  pu8VComp = v_comp[j];
+	  y_pos = 0;
+	  v_pos = 0;
+	  u_pos = 0;
+
+      for( i = 0; i < cinfo->output_width; i ++)
+      {
+		pu8YComp[y_pos] = pu8DecodedSrc[i * u32YUYVPixelSize];
+		y_pos ++;
+		
+		if(i & 0x1)
+		{
+		  pu8UComp[v_pos] = pu8DecodedSrc[(i * u32YUYVPixelSize) + 1];
+          v_pos ++;
+        }
+        else
+        {
+		  pu8VComp[u_pos] = pu8DecodedSrc[(i * u32YUYVPixelSize) + 1];
+          u_pos ++;
+		}
+	  }
+	}
+  }
+
+  if(cinfo->master->i32PixelFormat == V4L2_PIX_FMT_NV12)
+  {
+    unsigned char *pu8DecodedYSrc;
+    unsigned char *pu8DecodedUVSrc;
+    unsigned char *pu8DecodedSrc;
+    unsigned int u32NV12PixelSize = 1;
+    unsigned int u32RowBytes = cinfo->master->u32DecodeImageWidth * u32NV12PixelSize;
+
+    //copy Y component first
+	pu8DecodedYSrc = cinfo->master->pu8DecodedBuf;
+    for(j = 0; j < max_lines; j ++)
+    {
+	  pu8YComp = y_comp[j];
+	  pu8DecodedSrc = pu8DecodedYSrc + ((cinfo->output_scanline + j)* u32RowBytes);
+	  pu8DecodedSrc += cinfo->master->first_iMCU_col * u32NV12PixelSize;
+      memcpy(pu8YComp, pu8DecodedSrc, cinfo->output_width * u32NV12PixelSize);
+    }
+
+    //copy UV component
+	pu8DecodedUVSrc = pu8DecodedYSrc + (cinfo->master->u32DecodeImageWidth * cinfo->master->u32DecodeImageHeight * u32NV12PixelSize);
+    u32NV12PixelSize = 2;
+	u32RowBytes = cinfo->master->u32DecodeImageWidth / 2 * u32NV12PixelSize;
+    for(j = 0; j < (max_lines / 2); j  ++)
+    {
+      pu8DecodedSrc = pu8DecodedUVSrc + (((cinfo->output_scanline / 2) + j) * u32RowBytes);
+      pu8DecodedSrc += (cinfo->master->first_iMCU_col / 2) * u32NV12PixelSize;
+
+	  pu8UComp = u_comp[j];
+	  pu8VComp = v_comp[j];
+	  u_pos = 0;
+	  v_pos = 0;
+	  
+      for( i = 0; i < (cinfo->output_width / 2); i ++)
+      {
+        pu8UComp[u_pos] = pu8DecodedSrc[(i * u32NV12PixelSize)];
+        u_pos ++;
+        pu8VComp[v_pos] = pu8DecodedSrc[(i * u32NV12PixelSize) + 1];
+        v_pos ++;
+      }
+    }
+  }
+
+  return max_lines;
+}
+
+#endif
+
+
 GLOBAL(JDIMENSION)
 jpeg_read_raw_data(j_decompress_ptr cinfo, JSAMPIMAGE data,
                    JDIMENSION max_lines)
@@ -600,6 +1310,18 @@
     return 0;
   }
 
+#ifdef WITH_VC8000
+  if(cinfo->master->bHWJpegDecodeDone)
+  {
+	lines_per_iMCU_row = vc8000_read_raw_data(cinfo, data, max_lines);
+	if(lines_per_iMCU_row > 0){
+      cinfo->output_scanline += lines_per_iMCU_row;
+	  return lines_per_iMCU_row;
+	}
+  }
+
+#endif
+
   /* Call progress monitor hook if present */
   if (cinfo->progress != NULL) {
     cinfo->progress->pass_counter = (long)cinfo->output_scanline;
diff -Naur libjpeg-turbo-2.1.3/jdatadst.c libjpeg-turbo-2.1.3_new/jdatadst.c
--- libjpeg-turbo-2.1.3/jdatadst.c	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jdatadst.c	2022-04-06 10:38:23.819459390 +0800
@@ -20,6 +20,7 @@
 
 /* this is not a core library module, so it doesn't define JPEG_INTERNALS */
 #include "jinclude.h"
+#define JPEG_INTERNALS
 #include "jpeglib.h"
 #include "jerror.h"
 
@@ -285,3 +286,56 @@
   dest->pub.free_in_buffer = dest->bufsize = *outsize;
 }
 #endif
+
+#ifdef WITH_VC8000
+
+#include "vc8000_v4l2.h"
+#include "transupp.h"
+
+GLOBAL(int)
+jpeg_fb_dest(j_decompress_ptr cinfo, 
+			unsigned int fb_no,
+			unsigned int fb_width,
+            unsigned int fb_height,
+            unsigned int img_width,
+            unsigned int img_height,
+            unsigned int img_pos_x,
+            unsigned int img_pos_y,
+            JXFORM_CODE xform)
+{
+  struct jpeg_decomp_master *psMaster = cinfo->master;   
+
+  if((img_width + img_pos_x) > fb_width)
+    return -1;
+
+  if((img_height + img_pos_y) > fb_height)
+    return -2;
+
+  if(xform == JXFORM_NONE)
+	psMaster->sDirectFBParam.rotation_op = PP_ROTATION_NONE;
+  else if(xform == JXFORM_FLIP_H)
+	psMaster->sDirectFBParam.rotation_op = PP_ROTATION_HOR_FLIP;
+  else if(xform == JXFORM_FLIP_V)
+	psMaster->sDirectFBParam.rotation_op = PP_ROTATION_VER_FLIP;
+  else if(xform == JXFORM_ROT_90)
+	psMaster->sDirectFBParam.rotation_op = PP_ROTATION_RIGHT_90;
+  else if(xform == JXFORM_ROT_180)
+	psMaster->sDirectFBParam.rotation_op = PP_ROTATION_180;
+  else if(xform == JXFORM_ROT_270)
+	psMaster->sDirectFBParam.rotation_op = PP_ROTATION_LEFT_90;
+  else
+	return -3;
+
+  psMaster->bHWJpegDirectFBEnable = TRUE;
+  psMaster->sDirectFBParam.fb_no = fb_no;
+  psMaster->sDirectFBParam.fb_width = fb_width;
+  psMaster->sDirectFBParam.fb_height = fb_height;
+  psMaster->sDirectFBParam.img_width = img_width;
+  psMaster->sDirectFBParam.img_height = img_height;
+  psMaster->sDirectFBParam.img_pos_x = img_pos_x;
+  psMaster->sDirectFBParam.img_pos_y = img_pos_y;
+
+  return 0;
+}
+
+#endif
diff -Naur libjpeg-turbo-2.1.3/jdatasrc.c libjpeg-turbo-2.1.3_new/jdatasrc.c
--- libjpeg-turbo-2.1.3/jdatasrc.c	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jdatasrc.c	2022-04-06 10:38:23.819459390 +0800
@@ -20,6 +20,7 @@
 
 /* this is not a core library module, so it doesn't define JPEG_INTERNALS */
 #include "jinclude.h"
+#define JPEG_INTERNALS
 #include "jpeglib.h"
 #include "jerror.h"
 
@@ -123,6 +124,42 @@
   return TRUE;
 }
 
+#ifdef WITH_VC8000
+METHODDEF(boolean)
+file_fill_input_buffer(j_decompress_ptr cinfo)
+{
+  my_src_ptr src = (my_src_ptr)cinfo->master->src_hw_jpeg;
+  size_t nbytes;
+
+  nbytes = fread(src->buffer, 1, INPUT_BUF_SIZE, src->infile);
+
+  if (nbytes <= 0) {
+    if (src->start_of_file)     /* Treat empty input file as fatal error */
+      ERREXIT(cinfo, JERR_INPUT_EMPTY);
+	return FALSE;
+  }
+
+  src->pub.next_input_byte = src->buffer;
+  src->pub.bytes_in_buffer = nbytes;
+  src->start_of_file = FALSE;
+
+  return TRUE;
+}
+
+METHODDEF(long)
+file_seek_file_pos(j_decompress_ptr cinfo, long int offset, int origin)
+{
+  long u64CurPos;
+  my_src_ptr src = (my_src_ptr)cinfo->master->src_hw_jpeg;
+
+  u64CurPos = ftell(src->infile);	
+  fseek(src->infile, offset, origin);
+
+  return u64CurPos;
+}
+
+#endif
+
 #if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)
 METHODDEF(boolean)
 fill_mem_input_buffer(j_decompress_ptr cinfo)
@@ -250,6 +287,42 @@
   src->infile = infile;
   src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
   src->pub.next_input_byte = NULL; /* until buffer loaded */
+
+#ifdef WITH_VC8000
+  cinfo->master->eJpegSrcType = eJPEG_SRC_UNKNOWN;
+
+  if (cinfo->master->src_hw_jpeg == NULL) {     /* first time for this JPEG object? */
+    cinfo->master->src_hw_jpeg = (struct jpeg_source_mgr *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,
+                                  sizeof(my_source_mgr));
+    src = (my_src_ptr)cinfo->master->src_hw_jpeg;
+    src->buffer = (JOCTET *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,
+                                  INPUT_BUF_SIZE * sizeof(JOCTET));
+  } else if (cinfo->master->src_hw_jpeg->init_source != init_source) {
+    /* It is unsafe to reuse the existing source manager unless it was created
+     * by this function.  Otherwise, there is no guarantee that the opaque
+     * structure is the right size.  Note that we could just create a new
+     * structure, but the old structure would not be freed until
+     * jpeg_destroy_decompress() was called.
+     */
+    ERREXIT(cinfo, JERR_BUFFER_SIZE);
+  }
+
+  src = (my_src_ptr)cinfo->master->src_hw_jpeg;
+  src->pub.init_source = init_source;
+  src->pub.fill_input_buffer = file_fill_input_buffer;
+  src->pub.skip_input_data = skip_input_data;
+  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
+  src->pub.term_source = term_source;
+  src->infile = infile;
+  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
+  src->pub.next_input_byte = NULL; /* until buffer loaded */
+  cinfo->master->eJpegSrcType = eJPEG_SRC_FILE;
+  cinfo->master->seek_file_pos = file_seek_file_pos;
+
+#endif
+
 }
 
 
@@ -291,5 +364,32 @@
   src->term_source = term_source;
   src->bytes_in_buffer = (size_t)insize;
   src->next_input_byte = (const JOCTET *)inbuffer;
+
+#ifdef WITH_VC8000
+
+  cinfo->master->eJpegSrcType = eJPEG_SRC_UNKNOWN;
+
+  if (cinfo->master->src_hw_jpeg == NULL) {     /* first time for this JPEG object? */
+    cinfo->master->src_hw_jpeg = (struct jpeg_source_mgr *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,
+                                  sizeof(struct jpeg_source_mgr));
+  } else if (cinfo->master->src_hw_jpeg->init_source != init_mem_source) {
+    /* It is unsafe to reuse the existing source manager unless it was created
+     * by this function.
+     */
+    ERREXIT(cinfo, JERR_BUFFER_SIZE);
+  }
+
+  src = cinfo->master->src_hw_jpeg;
+  src->init_source = init_mem_source;
+  src->fill_input_buffer = fill_mem_input_buffer;
+  src->skip_input_data = skip_input_data;
+  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */
+  src->term_source = term_source;
+  src->bytes_in_buffer = (size_t)insize;
+  src->next_input_byte = (const JOCTET *)inbuffer;
+  cinfo->master->eJpegSrcType = eJPEG_SRC_MEM;
+  cinfo->master->pMemSrcBuf = NULL;
+#endif
 }
 #endif
diff -Naur libjpeg-turbo-2.1.3/jdatasrc-tj.c libjpeg-turbo-2.1.3_new/jdatasrc-tj.c
--- libjpeg-turbo-2.1.3/jdatasrc-tj.c	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jdatasrc-tj.c	2022-04-06 10:38:23.819459390 +0800
@@ -20,6 +20,7 @@
 
 /* this is not a core library module, so it doesn't define JPEG_INTERNALS */
 #include "jinclude.h"
+#define JPEG_INTERNALS
 #include "jpeglib.h"
 #include "jerror.h"
 
@@ -191,4 +192,30 @@
   src->term_source = term_source;
   src->bytes_in_buffer = (size_t)insize;
   src->next_input_byte = (const JOCTET *)inbuffer;
+
+#ifdef WITH_VC8000
+  cinfo->master->eJpegSrcType = eJPEG_SRC_UNKNOWN;
+
+  if (cinfo->master->src_hw_jpeg == NULL) {     /* first time for this JPEG object? */
+    cinfo->master->src_hw_jpeg = (struct jpeg_source_mgr *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,
+                                  sizeof(struct jpeg_source_mgr));
+  } else if (cinfo->master->src_hw_jpeg->init_source != init_mem_source) {
+    /* It is unsafe to reuse the existing source manager unless it was created
+     * by this function.
+     */
+    ERREXIT(cinfo, JERR_BUFFER_SIZE);
+  }
+
+  src = cinfo->master->src_hw_jpeg;
+  src->init_source = init_mem_source;
+  src->fill_input_buffer = fill_mem_input_buffer;
+  src->skip_input_data = skip_input_data;
+  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */
+  src->term_source = term_source;
+  src->bytes_in_buffer = (size_t)insize;
+  src->next_input_byte = (const JOCTET *)inbuffer;
+  cinfo->master->eJpegSrcType = eJPEG_SRC_MEM;
+#endif
+
 }
diff -Naur libjpeg-turbo-2.1.3/jpegint.h libjpeg-turbo-2.1.3_new/jpegint.h
--- libjpeg-turbo-2.1.3/jpegint.h	2022-02-26 02:53:05.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jpegint.h	2022-04-06 10:38:23.819459390 +0800
@@ -16,6 +16,9 @@
  * applications using the library shouldn't need to include this file.
  */
 
+#ifdef WITH_VC8000
+#include "vc8000_v4l2.h"		/* vc8000 hardware JPEG decoder support */
+#endif
 
 /* Declarations for both compression & decompression */
 
@@ -157,6 +160,26 @@
 
 /* Declarations for decompression modules */
 
+#ifdef WITH_VC8000
+struct jpeg_direct_fb_param {
+  unsigned int fb_no;
+  unsigned int fb_width;
+  unsigned int fb_height;
+  unsigned int img_width;
+  unsigned int img_height;
+  unsigned int img_pos_x;
+  unsigned int img_pos_y;
+  int rotation_op;
+};
+
+typedef enum {
+	eJPEG_SRC_UNKNOWN,
+	eJPEG_SRC_MEM,	
+	eJPEG_SRC_FILE	
+}E_JPEG_SRC_TYPE;
+
+#endif
+
 /* Master control module */
 struct jpeg_decomp_master {
   void (*prepare_for_output_pass) (j_decompress_ptr cinfo);
@@ -174,6 +197,30 @@
 
   /* Last iMCU row that was successfully decoded */
   JDIMENSION last_good_iMCU_row;
+
+#ifdef WITH_VC8000
+  long (*seek_file_pos) (j_decompress_ptr cinfo, long int offset, int origin);
+  E_JPEG_SRC_TYPE eJpegSrcType; 
+
+  /* Source of compressed data for HW JPEG decoder*/
+  struct jpeg_source_mgr *src_hw_jpeg;
+
+  boolean bHWJpegCodecOpened;
+  boolean bHWJpegDecodeDone;
+  boolean bHWJpegDeocdeEnable;
+  
+  unsigned char *pu8DecodedBuf;
+  int i32PixelFormat;
+  unsigned int u32DecodeImageWidth;
+  unsigned int u32DecodeImageHeight;
+
+  struct video sHWJpegVideo;
+
+  boolean bHWJpegDirectFBEnable;
+  struct jpeg_direct_fb_param sDirectFBParam;
+  
+  JOCTET *pMemSrcBuf;
+#endif
 };
 
 /* Input control module */
diff -Naur libjpeg-turbo-2.1.3/jpeglib_ext.h libjpeg-turbo-2.1.3_new/jpeglib_ext.h
--- libjpeg-turbo-2.1.3/jpeglib_ext.h	1970-01-01 08:00:00.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/jpeglib_ext.h	2022-04-06 10:38:23.823459390 +0800
@@ -0,0 +1,33 @@
+#ifndef JPEGLIB_EXT_H
+#define JPEGLIB_EXT_H
+
+#include "jpeglib.h"
+#include "transupp.h"
+
+#ifdef __cplusplus
+#ifndef DONT_USE_EXTERN_C
+extern "C" {
+#endif
+#endif
+
+EXTERN(void) jpeg_CreateDecompress_Ext(j_decompress_ptr cinfo, int version, size_t structsize, boolean enalbeHWDecode);
+
+EXTERN(int)
+jpeg_fb_dest(j_decompress_ptr cinfo, 
+			unsigned int fb_no,
+			unsigned int fb_width,
+            unsigned int fb_height,
+            unsigned int img_width,
+            unsigned int img_height,
+            unsigned int img_pos_x,
+            unsigned int img_pos_y,
+            JXFORM_CODE xform);
+
+
+#ifdef __cplusplus
+#ifndef DONT_USE_EXTERN_C
+}
+#endif
+#endif
+
+#endif
diff -Naur libjpeg-turbo-2.1.3/msm-v4l2-controls.h libjpeg-turbo-2.1.3_new/msm-v4l2-controls.h
--- libjpeg-turbo-2.1.3/msm-v4l2-controls.h	1970-01-01 08:00:00.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/msm-v4l2-controls.h	2022-04-06 10:38:23.823459390 +0800
@@ -0,0 +1,423 @@
+#ifndef __MSM_V4L2_CONTROLS_H__
+#define __MSM_V4L2_CONTROLS_H__
+
+//#include <linux/v4l2-controls.h>
+
+/*  MPEG-class control IDs specific to the msm_vidc driver */
+#define V4L2_CID_MPEG_MSM_VIDC_BASE		(V4L2_CTRL_CLASS_MPEG | 0x2000)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_ENABLE_PICTURE_TYPE \
+			(V4L2_CID_MPEG_MSM_VIDC_BASE+0)
+#define V4L2_CID_MPEG_VIDC_VIDEO_KEEP_ASPECT_RATIO \
+			(V4L2_CID_MPEG_MSM_VIDC_BASE+1)
+#define V4L2_CID_MPEG_VIDC_VIDEO_POST_LOOP_DEBLOCKER_MODE \
+			(V4L2_CID_MPEG_MSM_VIDC_BASE+2)
+#define V4L2_CID_MPEG_VIDC_VIDEO_DIVX_FORMAT \
+			(V4L2_CID_MPEG_MSM_VIDC_BASE+3)
+enum v4l2_mpeg_vidc_video_divx_format_type {
+	V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_4		= 0,
+	V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_5		= 1,
+	V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_6	    = 2,
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_MB_ERROR_MAP_REPORTING	\
+			(V4L2_CID_MPEG_MSM_VIDC_BASE+4)
+#define V4L2_CID_MPEG_VIDC_VIDEO_CONTINUE_DATA_TRANSFER \
+			(V4L2_CID_MPEG_MSM_VIDC_BASE+5)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT   (V4L2_CID_MPEG_MSM_VIDC_BASE+6)
+enum v4l2_mpeg_vidc_video_stream_format {
+	V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_STARTCODES         = 0,
+	V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_ONE_NAL_PER_BUFFER = 1,
+	V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_ONE_BYTE_LENGTH    = 2,
+	V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_TWO_BYTE_LENGTH    = 3,
+	V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_FOUR_BYTE_LENGTH   = 4,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_OUTPUT_ORDER   (V4L2_CID_MPEG_MSM_VIDC_BASE+7)
+enum v4l2_mpeg_vidc_video_output_order {
+	V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DISPLAY         = 0,
+	V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DECODE          = 1,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_FRAME_RATE   (V4L2_CID_MPEG_MSM_VIDC_BASE+8)
+#define V4L2_CID_MPEG_VIDC_VIDEO_IDR_PERIOD   (V4L2_CID_MPEG_MSM_VIDC_BASE+9)
+#define V4L2_CID_MPEG_VIDC_VIDEO_NUM_P_FRAMES (V4L2_CID_MPEG_MSM_VIDC_BASE+10)
+#define V4L2_CID_MPEG_VIDC_VIDEO_NUM_B_FRAMES (V4L2_CID_MPEG_MSM_VIDC_BASE+11)
+#define V4L2_CID_MPEG_VIDC_VIDEO_REQUEST_IFRAME (V4L2_CID_MPEG_MSM_VIDC_BASE+12)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL (V4L2_CID_MPEG_MSM_VIDC_BASE+13)
+enum v4l2_mpeg_vidc_video_rate_control {
+	V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL_OFF = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL_VBR_VFR = 1,
+	V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL_VBR_CFR = 2,
+	V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL_CBR_VFR = 3,
+	V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL_CBR_CFR = 4,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_ROTATION (V4L2_CID_MPEG_MSM_VIDC_BASE+14)
+enum v4l2_mpeg_vidc_video_rotation {
+	V4L2_CID_MPEG_VIDC_VIDEO_ROTATION_NONE = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_ROTATION_90 = 1,
+	V4L2_CID_MPEG_VIDC_VIDEO_ROTATION_180 = 2,
+	V4L2_CID_MPEG_VIDC_VIDEO_ROTATION_270 = 3,
+};
+#define MSM_VIDC_BASE V4L2_CID_MPEG_MSM_VIDC_BASE
+#define V4L2_CID_MPEG_VIDC_VIDEO_H264_CABAC_MODEL (MSM_VIDC_BASE+15)
+enum v4l2_mpeg_vidc_h264_cabac_model {
+	V4L2_CID_MPEG_VIDC_VIDEO_H264_CABAC_MODEL_0 = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_H264_CABAC_MODEL_1 = 1,
+	V4L2_CID_MPEG_VIDC_VIDEO_H264_CABAC_MODEL_2 = 2,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_INTRA_REFRESH_MODE (MSM_VIDC_BASE+16)
+enum v4l2_mpeg_vidc_video_intra_refresh_mode {
+	V4L2_CID_MPEG_VIDC_VIDEO_INTRA_REFRESH_NONE = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_INTRA_REFRESH_CYCLIC = 1,
+	V4L2_CID_MPEG_VIDC_VIDEO_INTRA_REFRESH_ADAPTIVE = 2,
+	V4L2_CID_MPEG_VIDC_VIDEO_INTRA_REFRESH_CYCLIC_ADAPTIVE = 3,
+	V4L2_CID_MPEG_VIDC_VIDEO_INTRA_REFRESH_RANDOM = 4,
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_AIR_MBS (V4L2_CID_MPEG_MSM_VIDC_BASE+17)
+#define V4L2_CID_MPEG_VIDC_VIDEO_AIR_REF (V4L2_CID_MPEG_MSM_VIDC_BASE+18)
+#define V4L2_CID_MPEG_VIDC_VIDEO_CIR_MBS (V4L2_CID_MPEG_MSM_VIDC_BASE+19)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_H263_PROFILE (V4L2_CID_MPEG_MSM_VIDC_BASE+20)
+enum v4l2_mpeg_vidc_video_h263_profile {
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_BASELINE = 0,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_H320CODING	= 1,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_BACKWARDCOMPATIBLE = 2,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_ISWV2 = 3,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_ISWV3 = 4,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_HIGHCOMPRESSION = 5,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_INTERNET = 6,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_INTERLACE = 7,
+	V4L2_MPEG_VIDC_VIDEO_H263_PROFILE_HIGHLATENCY = 8,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_H263_LEVEL (V4L2_CID_MPEG_MSM_VIDC_BASE+21)
+enum v4l2_mpeg_vidc_video_h263_level {
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_1_0 = 0,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_2_0 = 1,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_3_0 = 2,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_4_0 = 3,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_4_5 = 4,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_5_0 = 5,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_6_0 = 6,
+	V4L2_MPEG_VIDC_VIDEO_H263_LEVEL_7_0 = 7,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_H264_AU_DELIMITER \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 22)
+enum v4l2_mpeg_vidc_video_h264_au_delimiter {
+	V4L2_MPEG_VIDC_VIDEO_H264_AU_DELIMITER_DISABLED = 0,
+	V4L2_MPEG_VIDC_VIDEO_H264_AU_DELIMITER_ENABLED = 1
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_SYNC_FRAME_DECODE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 23)
+enum v4l2_mpeg_vidc_video_sync_frame_decode {
+	V4L2_MPEG_VIDC_VIDEO_SYNC_FRAME_DECODE_DISABLE = 0,
+	V4L2_MPEG_VIDC_VIDEO_SYNC_FRAME_DECODE_ENABLE = 1
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_SECURE (V4L2_CID_MPEG_MSM_VIDC_BASE+24)
+#define V4L2_CID_MPEG_VIDC_VIDEO_EXTRADATA \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 25)
+enum v4l2_mpeg_vidc_extradata {
+	V4L2_MPEG_VIDC_EXTRADATA_NONE = 0,
+	V4L2_MPEG_VIDC_EXTRADATA_MB_QUANTIZATION = 1,
+	V4L2_MPEG_VIDC_EXTRADATA_INTERLACE_VIDEO = 2,
+	V4L2_MPEG_VIDC_EXTRADATA_VC1_FRAMEDISP = 3,
+	V4L2_MPEG_VIDC_EXTRADATA_VC1_SEQDISP = 4,
+	V4L2_MPEG_VIDC_EXTRADATA_TIMESTAMP = 5,
+	V4L2_MPEG_VIDC_EXTRADATA_S3D_FRAME_PACKING = 6,
+	V4L2_MPEG_VIDC_EXTRADATA_FRAME_RATE = 7,
+	V4L2_MPEG_VIDC_EXTRADATA_PANSCAN_WINDOW = 8,
+	V4L2_MPEG_VIDC_EXTRADATA_RECOVERY_POINT_SEI = 9,
+	V4L2_MPEG_VIDC_EXTRADATA_MULTISLICE_INFO = 10,
+	V4L2_MPEG_VIDC_EXTRADATA_NUM_CONCEALED_MB = 11,
+	V4L2_MPEG_VIDC_EXTRADATA_METADATA_FILLER = 12,
+	V4L2_MPEG_VIDC_EXTRADATA_INPUT_CROP = 13,
+	V4L2_MPEG_VIDC_EXTRADATA_DIGITAL_ZOOM = 14,
+	V4L2_MPEG_VIDC_EXTRADATA_ASPECT_RATIO = 15,
+	V4L2_MPEG_VIDC_EXTRADATA_MPEG2_SEQDISP = 16,
+	V4L2_MPEG_VIDC_EXTRADATA_STREAM_USERDATA = 17,
+	V4L2_MPEG_VIDC_EXTRADATA_FRAME_QP = 18,
+	V4L2_MPEG_VIDC_EXTRADATA_FRAME_BITS_INFO = 19,
+	V4L2_MPEG_VIDC_EXTRADATA_LTR = 20,
+	V4L2_MPEG_VIDC_EXTRADATA_METADATA_MBI = 21,
+};
+
+#define V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL (V4L2_CID_MPEG_MSM_VIDC_BASE + 26)
+enum v4l2_mpeg_vidc_perf_level {
+	V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL			= 0,
+	V4L2_CID_MPEG_VIDC_PERF_LEVEL_PERFORMANCE		= 1,
+	V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO			= 2,
+};
+#define V4L2_CID_MPEG_VIDEO_MULTI_SLICE_GOB		\
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 27)
+
+#define V4L2_CID_MPEG_VIDEO_MULTI_SLICE_DELIVERY_MODE	\
+	(V4L2_CID_MPEG_MSM_VIDC_BASE + 28)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_H264_VUI_TIMING_INFO \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 29)
+enum v4l2_mpeg_vidc_video_h264_vui_timing_info {
+	V4L2_MPEG_VIDC_VIDEO_H264_VUI_TIMING_INFO_DISABLED = 0,
+	V4L2_MPEG_VIDC_VIDEO_H264_VUI_TIMING_INFO_ENABLED = 1
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_ALLOC_MODE_INPUT	\
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 30)
+#define V4L2_CID_MPEG_VIDC_VIDEO_ALLOC_MODE_OUTPUT       \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 31)
+enum v4l2_mpeg_vidc_video_alloc_mode_type {
+	V4L2_MPEG_VIDC_VIDEO_STATIC	= 0,
+	V4L2_MPEG_VIDC_VIDEO_RING	= 1,
+	V4L2_MPEG_VIDC_VIDEO_DYNAMIC	= 2,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_FRAME_ASSEMBLY	\
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 32)
+enum v4l2_mpeg_vidc_video_assembly {
+	V4L2_MPEG_VIDC_FRAME_ASSEMBLY_DISABLE	= 0,
+	V4L2_MPEG_VIDC_FRAME_ASSEMBLY_ENABLE	= 1,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_VP8_PROFILE_LEVEL \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 33)
+enum v4l2_mpeg_vidc_video_vp8_profile_level {
+	V4L2_MPEG_VIDC_VIDEO_VP8_UNUSED,
+	V4L2_MPEG_VIDC_VIDEO_VP8_VERSION_0,
+	V4L2_MPEG_VIDC_VIDEO_VP8_VERSION_1,
+	V4L2_MPEG_VIDC_VIDEO_VP8_VERSION_2,
+	V4L2_MPEG_VIDC_VIDEO_VP8_VERSION_3,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_H264_VUI_BITSTREAM_RESTRICT \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 34)
+enum v4l2_mpeg_vidc_video_h264_vui_bitstream_restrict {
+	V4L2_MPEG_VIDC_VIDEO_H264_VUI_BITSTREAM_RESTRICT_DISABLED = 0,
+	V4L2_MPEG_VIDC_VIDEO_H264_VUI_BITSTREAM_RESTRICT_ENABLED = 1
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_PRESERVE_TEXT_QUALITY \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 35)
+enum v4l2_mpeg_vidc_video_preserve_text_quality {
+	V4L2_MPEG_VIDC_VIDEO_PRESERVE_TEXT_QUALITY_DISABLED = 0,
+	V4L2_MPEG_VIDC_VIDEO_PRESERVE_TEXT_QUALITY_ENABLED = 1
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_DEINTERLACE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 36)
+enum v4l2_mpeg_vidc_video_deinterlace {
+	V4L2_CID_MPEG_VIDC_VIDEO_DEINTERLACE_DISABLED = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_DEINTERLACE_ENABLED = 1
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_MPEG4_TIME_RESOLUTION \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 37)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_STREAM_OUTPUT_MODE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 38)
+enum v4l2_mpeg_vidc_video_decoder_multi_stream {
+	V4L2_CID_MPEG_VIDC_VIDEO_STREAM_OUTPUT_PRIMARY = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_STREAM_OUTPUT_SECONDARY = 1,
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_SCS_THRESHOLD \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 39)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_MPEG2_LEVEL	(V4L2_CID_MPEG_MSM_VIDC_BASE+40)
+enum v4l2_mpeg_vidc_video_mpeg2_level {
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_LEVEL_0	= 0,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_LEVEL_1	= 1,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_LEVEL_2	= 2,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_LEVEL_3	= 3,
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_MPEG2_PROFILE	(V4L2_CID_MPEG_MSM_VIDC_BASE+41)
+enum v4l2_mpeg_vidc_video_mpeg2_profile {
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_PROFILE_SIMPLE		= 0,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_PROFILE_MAIN			= 1,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_PROFILE_422			= 2,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_PROFILE_SNR_SCALABLE		= 3,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_PROFILE_SPATIAL_SCALABLE	= 4,
+	V4L2_MPEG_VIDC_VIDEO_MPEG2_PROFILE_HIGH			= 5,
+};
+#define V4L2_CID_MPEG_VIDC_VIDEO_REQUEST_SEQ_HEADER \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 42)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_MVC_BUFFER_LAYOUT \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 43)
+enum v4l2_mpeg_vidc_video_mvc_layout {
+	V4L2_MPEG_VIDC_VIDEO_MVC_SEQUENTIAL = 0,
+	V4L2_MPEG_VIDC_VIDEO_MVC_TOP_BOTTOM = 1
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_VP8_MIN_QP (V4L2_CID_MPEG_MSM_VIDC_BASE + 44)
+#define V4L2_CID_MPEG_VIDC_VIDEO_VP8_MAX_QP (V4L2_CID_MPEG_MSM_VIDC_BASE + 45)
+#define V4L2_CID_MPEG_VIDC_VIDEO_CONCEAL_COLOR \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 46)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_LTRMODE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 47)
+
+enum v4l2_mpeg_vidc_video_ltrmode {
+	V4L2_MPEG_VIDC_VIDEO_LTR_MODE_DISABLE = 0,
+	V4L2_MPEG_VIDC_VIDEO_LTR_MODE_MANUAL = 1,
+	V4L2_MPEG_VIDC_VIDEO_LTR_MODE_PERIODIC = 2
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_LTRCOUNT \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 48)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_USELTRFRAME \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 49)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_MARKLTRFRAME \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 50)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_HIER_P_NUM_LAYERS \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 51)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_RATE_CONTROL_TIMESTAMP_MODE \
+	(V4L2_CID_MPEG_MSM_VIDC_BASE + 52)
+enum v4l2_mpeg_vidc_video_rate_control_timestamp_mode {
+	V4L2_MPEG_VIDC_VIDEO_RATE_CONTROL_TIMESTAMP_MODE_HONOR = 0,
+	V4L2_MPEG_VIDC_VIDEO_RATE_CONTROL_TIMESTAMP_MODE_IGNORE = 1,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_ENABLE_INITIAL_QP \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 53)
+enum vl42_mpeg_vidc_video_enable_initial_qp {
+	V4L2_CID_MPEG_VIDC_VIDEO_ENABLE_INITIAL_QP_IFRAME = 0x1,
+	V4L2_CID_MPEG_VIDC_VIDEO_ENABLE_INITIAL_QP_PFRAME = 0x2,
+	V4L2_CID_MPEG_VIDC_VIDEO_ENABLE_INITIAL_QP_BFRAME = 0x4,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_I_FRAME_QP \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 54)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_P_FRAME_QP \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 55)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_B_FRAME_QP \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 56)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 57)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_X_RANGE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 58)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_X_RANGE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 59)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_Y_RANGE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 60)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_Y_RANGE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 61)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_Y_RANGE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 62)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_VPX_ERROR_RESILIENCE \
+	(V4L2_CID_MPEG_MSM_VIDC_BASE + 63)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_BUFFER_SIZE_LIMIT \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 64)
+
+enum vl42_mpeg_vidc_video_vpx_error_resilience {
+	V4L2_MPEG_VIDC_VIDEO_VPX_ERROR_RESILIENCE_DISABLED = 0,
+	V4L2_MPEG_VIDC_VIDEO_VPX_ERROR_RESILIENCE_ENABLED = 1,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_HEVC_PROFILE \
+	(V4L2_CID_MPEG_MSM_VIDC_BASE + 65)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_HEVC_TIER_LEVEL \
+	(V4L2_CID_MPEG_MSM_VIDC_BASE + 66)
+
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC \
+	(V4L2_CID_MPEG_MSM_VIDC_BASE + 67)
+
+enum vl42_mpeg_vidc_video_h264_svc_nal {
+	V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC_DISABLED = 0,
+	V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC_ENABLED = 1,
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_PERF_MODE	 \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 68)
+
+enum v4l2_mpeg_vidc_video_perf_mode {
+	V4L2_MPEG_VIDC_VIDEO_PERF_MAX_QUALITY = 1,
+	V4L2_MPEG_VIDC_VIDEO_PERF_POWER_SAVE = 2
+};
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_HIER_B_NUM_LAYERS \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 69)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_SECURE_SCALING_THRESHOLD \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 70)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_NON_SECURE_OUTPUT2 \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 71)
+
+#define V4L2_CID_MPEG_VIDC_VIDEO_HYBRID_HIERP_MODE \
+		(V4L2_CID_MPEG_MSM_VIDC_BASE + 72)
+
+/* Vendor extensions */
+#define V4L2_QCOM_BUF_FLAG_CODECCONFIG		0x10000
+#define V4L2_QCOM_BUF_FLAG_EOSEQ		0x20000
+#define V4L2_QCOM_BUF_TIMESTAMP_INVALID		0x40000
+#define V4L2_QCOM_BUF_FLAG_IDRFRAME		0x80000	/*Image is a IDR-frame*/
+#define V4L2_QCOM_BUF_FLAG_DECODEONLY		0x100000
+#define V4L2_QCOM_BUF_DATA_CORRUPT		0x200000
+#define V4L2_QCOM_BUF_DROP_FRAME		0x400000
+#define V4L2_QCOM_BUF_INPUT_UNSUPPORTED		0x800000
+#define V4L2_QCOM_BUF_FLAG_EOS			0x1000000
+#define V4L2_QCOM_BUF_TS_DISCONTINUITY		0x2000000
+#define V4L2_QCOM_BUF_TS_ERROR			0x4000000
+#define V4L2_QCOM_BUF_FLAG_READONLY		0x8000000
+#define V4L2_MSM_VIDC_BUF_START_CODE_NOT_FOUND	0x10000000
+#define V4L2_MSM_BUF_FLAG_YUV_601_709_CLAMP	0x20000000
+#define V4L2_MSM_BUF_FLAG_MBAFF			0x40000000
+
+/* Capabilities */
+#define V4L2_CAP_QCOM_FRAMESKIP	0x2000	/*  frame skipping is supported */
+
+struct v4l2_qcom_frameskip {
+	__u64		   maxframeinterval;
+	__u8		   fpsvariance;
+};
+
+/* Encoder commands */
+#define V4L2_ENC_QCOM_CMD_FLUSH  (4)
+
+/* Decoder commands */
+#define V4L2_DEC_QCOM_CMD_FLUSH  (4)
+
+/* Flags for V4L2_DEC_QCOM_CMD_FLUSH */
+#define V4L2_DEC_QCOM_CMD_FLUSH_OUTPUT  (1 << 0)
+#define V4L2_DEC_QCOM_CMD_FLUSH_CAPTURE (1 << 1)
+
+#define V4L2_QCOM_CMD_FLUSH_OUTPUT  (1 << 0)
+#define V4L2_QCOM_CMD_FLUSH_CAPTURE (1 << 1)
+
+/* Events */
+#define V4L2_EVENT_MSM_VIDC_START	(V4L2_EVENT_PRIVATE_START + 0x00001000)
+#define V4L2_EVENT_MSM_VIDC_FLUSH_DONE	(V4L2_EVENT_MSM_VIDC_START + 1)
+#define V4L2_EVENT_MSM_VIDC_PORT_SETTINGS_CHANGED_SUFFICIENT	\
+		(V4L2_EVENT_MSM_VIDC_START + 2)
+#define V4L2_EVENT_MSM_VIDC_PORT_SETTINGS_CHANGED_INSUFFICIENT	\
+		(V4L2_EVENT_MSM_VIDC_START + 3)
+#define V4L2_EVENT_MSM_VIDC_CLOSE_DONE	(V4L2_EVENT_MSM_VIDC_START + 4)
+#define V4L2_EVENT_MSM_VIDC_SYS_ERROR	(V4L2_EVENT_MSM_VIDC_START + 5)
+#define V4L2_EVENT_MSM_VIDC_RELEASE_BUFFER_REFERENCE \
+		(V4L2_EVENT_MSM_VIDC_START + 6)
+#define V4L2_EVENT_MSM_VIDC_RELEASE_UNQUEUED_BUFFER \
+		(V4L2_EVENT_MSM_VIDC_START + 7)
+#define V4L2_EVENT_MSM_VIDC_HW_OVERLOAD (V4L2_EVENT_MSM_VIDC_START + 8)
+#define V4L2_EVENT_MSM_VIDC_MAX_CLIENTS (V4L2_EVENT_MSM_VIDC_START + 9)
+#define V4L2_EVENT_MSM_VIDC_HW_UNSUPPORTED (V4L2_EVENT_MSM_VIDC_START + 10)
+
+#endif/* __MSM_V4L2_CONTROLS_H__ */
diff -Naur libjpeg-turbo-2.1.3/vc8000_v4l2.c libjpeg-turbo-2.1.3_new/vc8000_v4l2.c
--- libjpeg-turbo-2.1.3/vc8000_v4l2.c	1970-01-01 08:00:00.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/vc8000_v4l2.c	2022-04-06 10:38:23.823459390 +0800
@@ -0,0 +1,984 @@
+/**
+ * @file vc8000_v4l2.c: vc8000 for v4l2 driver
+ *
+ * Copyright (C) 2021 nuvoton
+ */
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <poll.h>
+
+#include <pthread.h>
+
+#define VC8000_DEV_MAX_NO 4
+#define DEFAULT_VC8000_DEV_NAME "/dev/video0"
+
+//#define ENABLE_DBG
+
+#include "vc8000_v4l2.h"
+#include "msm-v4l2-controls.h"
+
+
+static char *dbg_type[2] = {"OUTPUT", "CAPTURE"};
+static char *dbg_status[2] = {"ON", "OFF"};
+
+static uint8_t *s_pu8FrameBufAddr = NULL;
+static uint32_t s_u32FrameBufSize = 0;
+static uint32_t s_u32FrameBufPlanes = 0;
+
+static pthread_mutex_t s_tHantroLock = PTHREAD_MUTEX_INITIALIZER;
+
+////////////////////////////////////////////////////////////////////////////////////////
+static int v4l2_queue_buf(
+	struct video *psVideo,
+	int n,
+	int l1,
+	int l2,
+	int type,
+	int nplanes
+)
+{
+	struct video *vid = psVideo;
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[MAX_PLANES];
+	int ret;
+	int p;
+
+	memzero(buf);
+	memset(planes, 0, sizeof(planes));
+	buf.type = type;
+	buf.memory = V4L2_MEMORY_MMAP;
+	buf.index = n;
+	buf.length = nplanes;
+	buf.m.planes = planes;
+
+	for(p = 0; p < nplanes; p ++)
+	{
+		buf.m.planes[p].bytesused = psVideo->cap_buf_planes_size[n][p];
+		buf.m.planes[p].data_offset = 0;
+
+		if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+			buf.m.planes[p].length = psVideo->cap_buf_planes_size[n][p];
+	}
+
+	if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		buf.m.planes[0].bytesused = l1;
+		//fprintf(stdout, "queue output buffer  %d lenght \n", l1);
+		buf.m.planes[0].length = vid->out_buf_size;
+		if (l1 == 0)
+			buf.flags |= V4L2_QCOM_BUF_FLAG_EOS;
+	}
+
+	ret = ioctl(vid->fd, VIDIOC_QBUF, &buf);
+	if (ret) {
+		fprintf(stderr, "Failed to queue buffer (index=%d) on %s (ret:%d)",
+		    buf.index,
+		    dbg_type[type==V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE], ret);
+		return -1;
+	}
+
+//	dbg("  Queued buffer on %s queue with index %d",
+//	    dbg_type[type==V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE], buf.index);
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "queue buffer buf.index %d done \n", buf.index);
+#endif
+
+	return 0;
+}
+
+static int v4l2_dequeue_buf(
+	struct video *psVideo,
+	struct v4l2_buffer *buf
+)
+{
+	struct video *vid = psVideo;
+	int ret;
+
+	ret = ioctl(vid->fd, VIDIOC_DQBUF, buf);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to dequeue buffer (%d)", -errno);
+		return -errno;
+	}
+
+//	dbg("Dequeued buffer on %s queue with index %d (flags:%x, bytesused:%d)",
+//	    dbg_type[buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE],
+//	    buf->index, buf->flags, buf->m.planes[0].bytesused);
+
+	return 0;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*
+ *  Private V4L2 post processing ioctl for VC8K
+ */
+
+struct vc8k_pp_params {
+	int   enable_pp;
+	unsigned int   frame_buf_paddr;           /* physical address of frame buffer          */
+	int   frame_buff_size;
+	int   frame_buf_w;               /* width of frame buffer width               */
+	int   frame_buf_h;               /* height of frame buffer                    */
+	int   img_out_x;                 /* image original point(x,y) on frame buffer */
+	int   img_out_y;                 /* image original point(x,y) on frame buffer */
+	int   img_out_w;                 /* image output width on frame buffer        */
+	int   img_out_h;                 /* image output height on frame buffer       */
+	int   img_out_fmt;               /* image output format                       */
+	int   rotation;
+	int   pp_out_dst;                /* PP output destination.                    */
+					 /* 0: fb0                                    */
+					 /* 1: fb1                                    */
+					 /* otherwise: frame_buf_paddr                */
+	int   libjpeg_mode;		 /* 0: v4l2-only; 1: libjpeg+v4l2             */
+	int   resserved[8];
+};
+
+
+#define VC8KIOC_PP_SET_CONFIG	_IOW ('v', 91, struct vc8k_pp_params)
+#define VC8KIOC_PP_GET_CONFIG	_IOW ('v', 92, struct vc8k_pp_params)
+#define VC8KIOC_GET_BUF_PHY_ADDR	_IOWR ('v', 193, struct v4l2_buffer)
+
+int vc8000_v4l2_open(struct video *psVideo)
+{
+	struct v4l2_capability cap;
+	int ret;
+	char strVideoDevNode[50];
+	int i32DefaultDevNodeLen = strlen(DEFAULT_VC8000_DEV_NAME);
+	int i = 0;
+	
+	memset(strVideoDevNode, 0, 50);
+	strcpy(strVideoDevNode, DEFAULT_VC8000_DEV_NAME);
+
+	for( i = 0; i < VC8000_DEV_MAX_NO; i ++) {
+		sprintf(strVideoDevNode + i32DefaultDevNodeLen - 1, "%d", i);
+
+		pthread_mutex_lock(&s_tHantroLock);
+		psVideo->fd = open(strVideoDevNode, O_RDWR, 0);
+		if (psVideo->fd < 0) {
+			fprintf(stderr, "Failed to open video decoder: %s \n", strVideoDevNode);
+			psVideo->fd = -1;
+			continue;
+		}
+
+		memzero(cap);
+		ret = ioctl(psVideo->fd, VIDIOC_QUERYCAP, &cap);
+		if (ret) {
+			fprintf(stderr, "Failed to verify capabilities \n");
+			close(psVideo->fd);
+			psVideo->fd = -1;
+			continue;
+		}
+
+#if defined (ENABLE_DBG)
+		fprintf(stdout, "caps (%s): driver=\"%s\" bus_info=\"%s\" card=\"%s\" fd=0x%x \n",
+			 strVideoDevNode, cap.driver, cap.bus_info, cap.card, psVideo->fd);
+#endif
+
+		if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) ||
+			!(cap.capabilities & V4L2_CAP_VIDEO_OUTPUT_MPLANE) ||
+			!(cap.capabilities & V4L2_CAP_STREAMING)) {
+			fprintf(stderr, "Insufficient capabilities for video device (is %s correct?) \n", strVideoDevNode);
+			close(psVideo->fd);
+			psVideo->fd = -1;
+			continue;
+		}
+
+		break;
+	}
+
+	if(psVideo->fd < 0) {
+		pthread_mutex_unlock(&s_tHantroLock);
+		return -1;
+	}
+	
+	return 0;
+}
+
+void vc8000_v4l2_close(struct video *psVideo)
+{
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "vc8000_v4l2_close video fd %x \n", psVideo->fd);
+#endif
+	close(psVideo->fd);
+	pthread_mutex_unlock(&s_tHantroLock);
+}
+
+//setup output(bitstream) plane
+int vc8000_v4l2_setup_output(
+	struct video *psVideo,
+	unsigned long codec,
+	unsigned int size,
+	int count
+)
+{
+	struct video *vid = psVideo;
+	struct v4l2_format fmt;
+	struct v4l2_requestbuffers reqbuf;
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[OUT_PLANES];
+	int ret;
+	int n;
+
+	memzero(fmt);
+	fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	fmt.fmt.pix_mp.width = MAX_DEC_OUTPUT_WIDTH;
+	fmt.fmt.pix_mp.height = MAX_DEC_OUTPUT_HEIGHT;
+	fmt.fmt.pix_mp.pixelformat = codec;
+	fmt.fmt.pix_mp.plane_fmt[0].sizeimage = size;
+
+	ret = ioctl(vid->fd, VIDIOC_S_FMT, &fmt);
+	if (ret) {
+		fprintf(stderr, "Failed to set format on OUTPUT (%s) \n", strerror(errno));
+		return -1;
+	}
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "Setup decoding OUTPUT buffer size=%u (requested=%u) \n",
+	    fmt.fmt.pix_mp.plane_fmt[0].sizeimage, size);
+#endif
+
+	vid->out_buf_size = fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	memzero(reqbuf);
+	reqbuf.count = count;
+	reqbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	reqbuf.memory = V4L2_MEMORY_MMAP;
+
+	ret = ioctl(vid->fd, VIDIOC_REQBUFS, &reqbuf);
+	if (ret) {
+		fprintf(stderr, "REQBUFS failed on OUTPUT queue \n");
+		return -1;
+	}
+
+	vid->out_buf_cnt = reqbuf.count;
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "Number of video decoder OUTPUT buffers is %d (requested %d) \n",
+	    vid->out_buf_cnt, count);
+#endif
+
+	for (n = 0; n < vid->out_buf_cnt; n++) {
+		memzero(buf);
+		memset(planes, 0, sizeof(planes));
+		buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+		buf.memory = V4L2_MEMORY_MMAP;
+		buf.index = n;
+		buf.m.planes = planes;
+		buf.length = OUT_PLANES;
+
+		ret = ioctl(vid->fd, VIDIOC_QUERYBUF, &buf);
+		if (ret != 0) {
+			fprintf(stderr, "QUERYBUF failed on OUTPUT buffer \n");
+			return -1;
+		}
+
+		vid->out_buf_off[n] = buf.m.planes[0].m.mem_offset;
+		vid->out_buf_size = buf.m.planes[0].length;
+
+		vid->out_buf_addr[n] = mmap(NULL, buf.m.planes[0].length,
+					    PROT_READ | PROT_WRITE, MAP_SHARED,
+					    vid->fd,
+					    buf.m.planes[0].m.mem_offset);
+
+		if (vid->out_buf_addr[n] == MAP_FAILED) {
+			fprintf(stderr, "Failed to MMAP OUTPUT buffer \n");
+			return -1;
+		}
+
+		vid->out_buf_flag[n] = eV4L2_BUF_DEQUEUE;
+	}
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "Succesfully mmapped %d OUTPUT buffers \n", n);
+#endif
+
+	return 0;
+}
+
+void vc8000_v4l2_release_output(
+	struct video *psVideo
+)
+{
+	struct video *vid = psVideo;
+	int n;
+	
+	for(n = 0; n < vid->out_buf_cnt; n++)
+	{
+		if(vid->out_buf_addr[n])
+		{
+#if defined (ENABLE_DBG)
+			fprintf(stdout, "unmap output memeory n:%d , addr:%x, size %d \n", n, vid->out_buf_addr[n], vid->out_buf_size);
+#endif
+			if(munmap(vid->out_buf_addr[n], vid->out_buf_size) != 0)
+			{
+#if defined (ENABLE_DBG)
+				fprintf(stdout, "unable unmap output memeory %p\n", vid->out_buf_addr[n]);
+#endif
+			}
+			vid->out_buf_addr[n] = NULL;			
+		}
+
+	}
+
+}
+
+/* 
+Setup capture(decoded) plane
+pixel_format: 
+	V4L2_PIX_FMT_NV12
+	V4L2_PIX_FMT_ARGB32
+	V4L2_PIX_FMT_RGB565
+*/
+
+int vc8000_v4l2_setup_capture(struct video *psVideo, int pixel_format, int buf_cnt, int w, int h)
+{
+	struct video *vid = psVideo;
+	struct v4l2_format fmt;
+	struct v4l2_requestbuffers reqbuf;
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[MAX_PLANES];
+	int ret;
+	int n,p;
+
+	memzero(fmt);
+	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+
+#if 0
+	if(psVideoPP->enabled)
+	{
+		//driver directly output framebuffer, so set tiny image size to save memory usage
+		fmt.fmt.pix_mp.height = 48;
+		fmt.fmt.pix_mp.width = 48;
+	}
+	else
+	{
+		fmt.fmt.pix_mp.height = h;
+		fmt.fmt.pix_mp.width = w;
+	}
+#else
+	fmt.fmt.pix_mp.height = h;
+	fmt.fmt.pix_mp.width = w;
+#endif
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "video_setup_capture: %dx%d\n", w, h);
+#endif
+	fmt.fmt.pix_mp.pixelformat = pixel_format;
+
+	if(fmt.fmt.pix_mp.pixelformat == V4L2_PIX_FMT_RGB565)
+	{
+		//Kernel(v4l2_format_info) not support sizeimage for RGB565, set it by myself
+		fmt.fmt.pix_mp.plane_fmt[0].sizeimage = fmt.fmt.pix_mp.height * fmt.fmt.pix_mp.width * 2; //2:bpp 
+	}
+
+	ret = ioctl(vid->fd, VIDIOC_S_FMT, &fmt);
+	if (ret) {
+		fprintf(stderr, "Failed to set format (%dx%d) \n", w, h);
+		return -1;
+	}
+
+	vid->cap_w = fmt.fmt.pix_mp.width;
+	vid->cap_h = fmt.fmt.pix_mp.height;
+
+	vid->cap_buf_num_planes = fmt.fmt.pix_mp.num_planes;
+	
+	for(p = 0; p < vid->cap_buf_num_planes; p ++)
+	{
+		if(fmt.fmt.pix_mp.plane_fmt[p].sizeimage == 0)
+		{
+			fprintf(stderr, "video decoder buffer plane[%d]:%d bytes \n",
+				p, fmt.fmt.pix_mp.plane_fmt[p].sizeimage);
+		}
+	}
+
+	vid->cap_buf_cnt = buf_cnt;
+	vid->cap_buf_cnt_min = 1;
+	vid->cap_buf_queued = 0;
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "video decoder buffer parameters: %dx%d, planes: %d \n",
+	    fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.num_planes);
+#endif
+
+	memzero(reqbuf);
+	reqbuf.count = vid->cap_buf_cnt;
+	reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	reqbuf.memory = V4L2_MEMORY_MMAP;
+
+	ret = ioctl(vid->fd, VIDIOC_REQBUFS, &reqbuf);
+	if (ret != 0) {
+		fprintf(stderr, "REQBUFS failed on CAPTURE queue (%s) \n", strerror(errno));
+		return -1;
+	}
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "Number of CAPTURE buffers is %d (requested %d, extra %d) \n",
+	    reqbuf.count, vid->cap_buf_cnt, buf_cnt);
+#endif
+
+	vid->cap_buf_cnt = reqbuf.count;
+
+	for (n = 0; n < vid->cap_buf_cnt; n++) {
+		memzero(buf);
+		memset(planes, 0, sizeof(planes));
+		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+		buf.memory = V4L2_MEMORY_MMAP;
+		buf.index = n;
+		buf.m.planes = planes;
+		buf.length = vid->cap_buf_num_planes;
+
+		ret = ioctl(vid->fd, VIDIOC_QUERYBUF, &buf);
+		if (ret != 0) {
+			fprintf(stderr, "QUERYBUF failed on CAPTURE queue (%s) \n", strerror(errno));
+			return -1;
+		}
+		
+		for(p = 0; p < vid->cap_buf_num_planes; p ++){
+
+			vid->cap_buf_off[n][p] = buf.m.planes[p].m.mem_offset;
+
+			vid->cap_buf_addr[n][p] = mmap(NULL, buf.m.planes[p].length,
+							   PROT_READ | PROT_WRITE,
+							   MAP_SHARED,
+							   vid->fd,
+							   buf.m.planes[p].m.mem_offset);
+
+			if (vid->cap_buf_addr[n][p] == MAP_FAILED) {
+				fprintf(stderr, "Failed to MMAP CAPTURE buffer on plane0 \n");
+				return -1;
+			}
+
+			vid->cap_buf_flag[n] = eV4L2_BUF_DEQUEUE;
+			vid->cap_buf_planes_size[n][p] = buf.m.planes[p].length;
+#if defined (ENABLE_DBG)
+			fprintf(stdout, "video decoder buffer plane[%d]:%d bytes and address %x \n",
+				p, vid->cap_buf_planes_size[n][p], vid->cap_buf_addr[n][p]);
+#endif
+		}
+	}
+
+#if 0
+	//get capture buffer DMA address
+	for (n = 0; n < vid->cap_buf_cnt; n++) {
+		memzero(buf);
+		memset(planes, 0, sizeof(planes));
+		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+		buf.memory = V4L2_MEMORY_MMAP;
+		buf.index = n;
+
+		ret = ioctl(vid->fd, VC8KIOC_GET_BUF_PHY_ADDR, &buf);
+		if (ret != 0) {
+			fprintf(stderr, "VC8KIOC_GET_BUF_PHY_ADDR failed on CAPTURE queue (%s) \n", strerror(errno));
+			return -1;
+		}
+		
+		fprintf(stderr, "VC8KIOC_GET_BUF_PHY_ADDR address:%x \n", buf.reserved);
+		
+//		vid->cap_buf_dma_addr[n][0] = buf.reserved;
+	}
+#endif
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "Succesfully mmapped %d CAPTURE buffers \n", n);
+#endif
+	return 0;
+}
+
+
+int vc8000_v4l2_setup_post_processing(struct video *psVideo,
+	bool bEnablePP,
+	int pixel_format,
+	int w,
+	int h,
+	int x,
+	int y,
+	int rot_op,
+	struct video_fb_info *psFBInfo)
+{
+	struct vc8k_pp_params  sVC8K_PP;
+
+	sVC8K_PP.enable_pp = bEnablePP;
+	sVC8K_PP.frame_buff_size = psFBInfo->frame_buf_size;
+	sVC8K_PP.frame_buf_paddr= psFBInfo->frame_buf_paddr;
+	sVC8K_PP.frame_buf_w = psFBInfo->frame_buf_w;
+	sVC8K_PP.frame_buf_h = psFBInfo->frame_buf_h;
+	sVC8K_PP.img_out_x = x;
+	sVC8K_PP.img_out_y = y;
+	sVC8K_PP.img_out_w = w;
+	sVC8K_PP.img_out_h = h;
+	sVC8K_PP.rotation = rot_op;
+	sVC8K_PP.img_out_fmt = pixel_format;
+	sVC8K_PP.pp_out_dst = psFBInfo->frame_buf_no;
+	sVC8K_PP.libjpeg_mode = 1;
+		
+	ioctl(psVideo->fd, VC8KIOC_PP_SET_CONFIG, &sVC8K_PP);
+
+#if defined (ENABLE_DBG)
+//	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.enable_pp %x \n", sVC8K_PP.enable_pp);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.frame_buf_paddr %p \n", sVC8K_PP.frame_buf_paddr);
+//	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.frame_buff_size %d \n", sVC8K_PP.frame_buff_size);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.frame_buf_w %d \n", sVC8K_PP.frame_buf_w);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.frame_buf_h %d \n", sVC8K_PP.frame_buf_h);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.img_out_x %d \n", sVC8K_PP.img_out_x);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.img_out_y %d \n", sVC8K_PP.img_out_y);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.img_out_w %d \n", sVC8K_PP.img_out_w);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.img_out_h %d \n", sVC8K_PP.img_out_h);
+	printf("DDDDD vc8000_v4l2_setup_post_processing sVC8K_PP.img_out_fmt %d \n", sVC8K_PP.img_out_fmt);
+#endif
+	return 0;
+
+}
+
+void vc8000_v4l2_release_capture(
+	struct video *psVideo
+)
+{
+	struct video *vid = psVideo;
+	int n,p;
+	
+	for(n = 0; n < vid->cap_buf_cnt; n++)
+	{
+
+		for(p = 0; p < vid->cap_buf_num_planes; p++)
+		{
+
+			if(vid->cap_buf_addr[n][p])
+			{
+#if defined (ENABLE_DBG)
+				fprintf(stdout, "unmap capture memeory n:%d, p:%d, addr:%x, size %d \n", n, p, vid->cap_buf_addr[n][p], vid->cap_buf_planes_size[n][p]);
+#endif
+				if(munmap(vid->cap_buf_addr[n][p], vid->cap_buf_planes_size[n][p]) != 0)
+				{
+#if defined (ENABLE_DBG)
+					fprintf(stdout, "unable unmap capture memeory %p\n", vid->cap_buf_addr[n][p]);
+#endif
+				}
+				vid->cap_buf_addr[n][p] = NULL;			
+			}
+		}
+	}
+}
+
+int vc8000_v4l2_queue_output(
+	struct video *psVideo,
+	int n,
+	int length
+)
+{
+	struct video *vid = psVideo;
+
+	if (n >= vid->out_buf_cnt) {
+		fprintf(stderr, "Tried to queue a non exisiting buffer \n");
+		return -1;
+	}
+
+	return v4l2_queue_buf(psVideo, n, length, 0,
+			       V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, OUT_PLANES);
+}
+
+int vc8000_v4l2_queue_capture(
+	struct video *psVideo,
+	int n
+)
+{
+	struct video *vid = psVideo;
+
+	if (n >= vid->cap_buf_cnt) {
+		fprintf(stderr, "Tried to queue a non exisiting buffer \n");
+		return -1;
+	}
+
+	return v4l2_queue_buf(psVideo, n, vid->cap_buf_planes_size[n][0], vid->cap_buf_planes_size[n][0],
+			       V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, psVideo->cap_buf_num_planes);
+}
+
+int vc8000_v4l2_dequeue_output(
+	struct video *psVideo,
+	int *n
+)
+{
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[OUT_PLANES];
+	int ret;
+
+	memzero(buf);
+	buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	buf.memory = V4L2_MEMORY_MMAP;
+	buf.m.planes = planes;
+	buf.length = OUT_PLANES;
+
+	ret = v4l2_dequeue_buf(psVideo, &buf);
+	if (ret < 0)
+		return ret;
+
+	*n = buf.index;
+
+	return 0;
+}
+
+int vc8000_v4l2_dequeue_capture(
+	struct video *psVideo,
+	int *n, 
+	int *finished,
+	unsigned int *bytesused
+)
+{
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[MAX_PLANES];
+
+	memzero(buf);
+	buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	buf.memory = V4L2_MEMORY_MMAP;
+	buf.m.planes = planes;
+	buf.length = psVideo->cap_buf_num_planes; //CAP_PLANES;
+
+	if (v4l2_dequeue_buf(psVideo, &buf))
+		return -1;
+
+	*finished = 0;
+
+	if (buf.flags & V4L2_BUF_FLAG_DONE ||
+	    buf.m.planes[0].bytesused)
+		*finished = 1;
+
+	if (buf.flags & V4L2_BUF_FLAG_ERROR)
+		*finished = 0;
+
+	*bytesused = buf.m.planes[0].bytesused;
+	*n = buf.index;
+
+	return 0;
+}
+
+int vc8000_v4l2_stream(
+	struct video *psVideo,
+	enum v4l2_buf_type type, 
+	int status
+)
+{
+	struct video *vid = psVideo;
+	int ret;
+
+	ret = ioctl(vid->fd, status, &type);
+	if (ret) {
+		fprintf(stderr, "Failed to change streaming (type=%s, status=%s) \n",
+		    dbg_type[type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE],
+		    dbg_status[status == VIDIOC_STREAMOFF]);
+		return -1;
+	}
+
+#if defined (ENABLE_DBG)
+	fprintf(stdout, "Stream %s on %s queue \n", dbg_status[status==VIDIOC_STREAMOFF],
+	    dbg_type[type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE]);
+#endif
+
+	return 0;
+}
+
+int vc8000_v4l2_stop_capture(
+	struct video *psVideo
+)
+{
+	int ret;
+	struct v4l2_requestbuffers reqbuf;
+	struct video *vid = psVideo;
+
+	ret = vc8000_v4l2_stream(psVideo, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+			   VIDIOC_STREAMOFF);
+	if (ret < 0)
+		fprintf(stderr, "STREAMOFF CAPTURE queue failed (%s) \n", strerror(errno));
+
+	memzero(reqbuf);
+	reqbuf.memory = V4L2_MEMORY_MMAP;
+	reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+
+	ret = ioctl(vid->fd, VIDIOC_REQBUFS, &reqbuf);
+	if (ret < 0) {
+		fprintf(stderr, "REQBUFS with count=0 on CAPTURE queue failed (%s) \n", strerror(errno));
+		return -1;
+	}
+
+	vc8000_v4l2_release_capture(psVideo);
+
+	return 0;
+}
+
+int vc8000_v4l2_stop_output(
+	struct video *psVideo
+)
+{
+	int ret;
+	struct v4l2_requestbuffers reqbuf;
+	struct video *vid = psVideo;
+
+	ret = vc8000_v4l2_stream(psVideo, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+			   VIDIOC_STREAMOFF);
+	if (ret < 0)
+		fprintf(stderr, "STREAMOFF OUTPUT queue failed (%s) \n", strerror(errno));
+
+	memzero(reqbuf);
+	reqbuf.memory = V4L2_MEMORY_MMAP;
+	reqbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+
+	ret = ioctl(vid->fd, VIDIOC_REQBUFS, &reqbuf);
+	if (ret < 0) {
+		fprintf(stderr, "REQBUFS with count=0 on OUTPUT queue failed (%s) \n", strerror(errno));
+		return -1;
+	}
+
+	vc8000_v4l2_release_output(psVideo);
+
+	return 0;
+}
+
+int vc8000_v4l2_stop(
+	struct video *psVideo
+)
+{
+	vc8000_v4l2_stop_capture(psVideo);
+	vc8000_v4l2_stop_output(psVideo);
+
+	return 0;
+}
+
+#define PP_OUT_MAX_WIDTH_UPSCALED(d) (3*(d))
+#define PP_OUT_MAX_HEIGHT_UPSCALED(d) (3*(d) - 2)
+
+int vc8000_jpeg_prepare_decompress(
+	struct video *psVideo,
+	uint32_t u32ImageWidth,
+	uint32_t u32ImageHeight,
+	uint32_t u32OutputWidth,
+	uint32_t u32OutputHeight,
+	bool bDirectFBOut,
+	struct video_fb_info *psFBInfo,
+	uint32_t u32ImgFBPosX,
+	uint32_t u32ImgFBPosY,	
+	int i32RotOP,
+	int pixel_format
+)
+{
+	int i32Ret = 0; 
+	int n;
+
+	if(psVideo->fd < 0)
+		return -1;
+
+	if((u32OutputWidth > MAX_DEC_OUTPUT_WIDTH) || (u32OutputHeight > MAX_DEC_OUTPUT_HEIGHT))
+		return -2;
+
+	//check PP parameter
+	if(u32OutputWidth > PP_OUT_MAX_WIDTH_UPSCALED(u32ImageWidth))
+	{
+		fprintf(stderr, "Upscale factory is over PP support\n");
+		return -3;
+	}
+
+	if(u32OutputHeight > PP_OUT_MAX_HEIGHT_UPSCALED(u32ImageHeight))
+	{
+		fprintf(stderr, "Upscale factory is over PP support \n");
+		return -4;
+	}
+
+
+	i32Ret = vc8000_v4l2_setup_output(psVideo, 
+								V4L2_PIX_FMT_JPEG, 
+								u32ImageWidth * u32ImageHeight, 
+								1);
+	if(i32Ret != 0){
+		return -5;
+	}
+
+	if(bDirectFBOut == true){
+		i32Ret = vc8000_v4l2_setup_capture(psVideo, 
+									pixel_format, 
+									1, 
+									32,
+									32
+									);
+	}
+	else {
+		i32Ret = vc8000_v4l2_setup_capture(psVideo, 
+									pixel_format, 
+									1, 
+									u32OutputWidth,
+									u32OutputHeight
+									);
+	}
+
+	if(i32Ret != 0){
+		vc8000_v4l2_release_output(psVideo);
+		return -6;
+	}
+
+//    struct video_fb_info sFBInfo;
+	if(bDirectFBOut == true)
+	{
+		//psFBInfo frame buffer parameter provided by caller
+		psFBInfo->frame_buf_paddr = 0;
+		psFBInfo->direct_fb_out = 1;
+	}
+	else
+	{
+		psFBInfo->frame_buf_paddr = 0;
+		psFBInfo->frame_buf_size = 0;
+		psFBInfo->frame_buf_w = psVideo->cap_w;
+		psFBInfo->frame_buf_h = psVideo->cap_h;
+		psFBInfo->direct_fb_out = 0;
+		u32OutputWidth = psVideo->cap_w;
+		u32OutputHeight = psVideo->cap_h;		
+	}
+	
+	vc8000_v4l2_setup_post_processing(psVideo, true, pixel_format, u32OutputWidth, u32OutputHeight, u32ImgFBPosX, u32ImgFBPosY, i32RotOP, psFBInfo);
+	    
+	vc8000_v4l2_stream(psVideo, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON);
+    vc8000_v4l2_stream(psVideo, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON);                
+
+	//put capture dequeued buffer into queue
+	for(n = 0; n < psVideo->cap_buf_cnt; n ++)
+	{
+			if(psVideo->cap_buf_flag[n] == eV4L2_BUF_DEQUEUE)
+			{
+					vc8000_v4l2_queue_capture(psVideo, n);
+					psVideo->cap_buf_flag[n] = eV4L2_BUF_INQUEUE;
+			}       
+	}
+
+	return 0;
+}
+
+int vc8000_jpeg_get_bitstream_buffer(
+	struct video *psVideo,
+	char **ppchBufferAddr
+)
+{
+	int n;
+	*ppchBufferAddr = NULL;
+	
+	//Get output dequeued buffer 
+	for(n = 0; n < psVideo->out_buf_cnt; n ++)
+	{
+		if(psVideo->out_buf_flag[n] == eV4L2_BUF_DEQUEUE)
+		{
+			*ppchBufferAddr = psVideo->out_buf_addr[n];
+			break;
+		}
+	}
+
+	return psVideo->out_buf_size;
+}
+
+int vc8000_jpeg_inqueue_bitstream_buffer(
+	struct video *psVideo,
+	char *pchBufferAddr,
+	uint32_t u32StreamLen
+)
+{
+	int n;
+	int ret;
+	//Get output dequeued buffer index
+	for(n = 0; n < psVideo->out_buf_cnt; n ++)
+	{
+		if(psVideo->out_buf_addr[n] == pchBufferAddr)
+		{
+			ret = vc8000_v4l2_queue_output(psVideo, n, u32StreamLen);
+			psVideo->out_buf_flag[n] = eV4L2_BUF_INQUEUE;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+int vc8000_jpeg_poll_decode_done(
+        struct video *psVideo,
+        int *p_cap_index
+)
+{
+	struct pollfd pfd;
+	short revents;
+	int ret, cap_index, finished, output_index;
+
+	pfd.fd = psVideo->fd;
+	pfd.events = POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM |
+				 POLLRDBAND | POLLPRI;
+
+	ret = -1;
+	cap_index = -1;
+	output_index = -1;
+
+	while (1) {
+		//ret = poll(&pfd, 1, 2000);
+		ret = poll(&pfd, 1, -1);
+
+		if (!ret) {
+			//timeout
+			ret = -1;
+			break;
+		} else if (ret < 0) {
+			fprintf(stderr, "poll error");
+			ret = -2;
+			break;
+		}
+
+		revents = pfd.revents;
+
+		if (revents & (POLLIN | POLLRDNORM)) {
+			unsigned int bytesused;
+
+			/* capture buffer is ready */
+
+			ret = vc8000_v4l2_dequeue_capture(psVideo, &cap_index, &finished,
+										&bytesused);
+			if (ret < 0)
+					goto next_event;
+
+			psVideo->cap_buf_flag[cap_index] = eV4L2_BUF_DEQUEUE;
+			psVideo->total_captured++;
+
+			//fprintf(stdout, "decoded frame %ld", vid->total_captured);
+		}
+
+next_event:
+
+		if (revents & (POLLOUT | POLLWRNORM)) {
+
+			ret = vc8000_v4l2_dequeue_output(psVideo, &output_index);
+			if (ret < 0) {
+					fprintf(stderr, "dequeue output buffer fail");
+			} else {
+					psVideo->out_buf_flag[output_index] = eV4L2_BUF_DEQUEUE;
+			}
+
+			break;
+			// dbg("dequeued output buffer %d", n);
+		}
+	}
+
+	*p_cap_index = cap_index;
+
+	if (finished == 0) {
+		return -3;
+	}
+
+//	fprintf(stdout, "vc8000_jpeg_poll_decode_done result %d \n", ret);
+	return ret;
+}
+
+int vc8000_jpeg_release_decompress(
+        struct video *psVideo
+)
+{
+	vc8000_v4l2_stop(psVideo);
+}
+
+
+
diff -Naur libjpeg-turbo-2.1.3/vc8000_v4l2.h libjpeg-turbo-2.1.3_new/vc8000_v4l2.h
--- libjpeg-turbo-2.1.3/vc8000_v4l2.h	1970-01-01 08:00:00.000000000 +0800
+++ libjpeg-turbo-2.1.3_new/vc8000_v4l2.h	2022-04-06 10:38:23.823459390 +0800
@@ -0,0 +1,238 @@
+/**
+ * @file vc8000_v4l2.h vc8000 v4l2 driver
+ *
+ * Copyright (C) 2021 nuvotn
+ */
+
+#ifndef __VC8000_V4L2_H__
+#define __VC8000_V4L2_H__
+
+#include <stdio.h>
+#include <time.h>
+#include <inttypes.h>
+#include <linux/videodev2.h>
+
+/*
+ * Boolean type
+ * see http://www.opengroup.org/onlinepubs/000095399/basedefs/stdbool.h.html
+ *     www.gnu.org/software/autoconf/manual/html_node/Particular-Headers.html
+ */
+#ifdef HAVE_STDBOOL_H
+# include <stdbool.h>
+#else
+# ifndef HAVE__BOOL
+#  ifdef __cplusplus
+typedef bool _Bool;
+#  else
+#   define _Bool signed char
+#  endif
+# endif
+# define bool _Bool
+# define false 0
+# define true 1
+# define __bool_true_false_are_defined 1
+#endif
+
+/* Maximum number of output buffers */
+#define MAX_OUT_BUF		16
+
+/* Maximum number of capture buffers (32 is the limit imposed by MFC */
+#define MAX_CAP_BUF		32
+
+/* Number of output planes */
+#define OUT_PLANES		1
+
+/* Number of capture planes */
+//#define CAP_PLANES		1
+#define CAP_PLANES		3
+
+/* Maximum number of planes used in the application */
+#define MAX_PLANES		CAP_PLANES
+
+/* Maximum decode resolution*/
+#define MAX_DEC_OUTPUT_WIDTH          1920
+#define MAX_DEC_OUTPUT_HEIGHT         1080
+
+/* Post processing rotation operation */
+#define PP_ROTATION_NONE                                0U
+#define PP_ROTATION_RIGHT_90                            1U
+#define PP_ROTATION_LEFT_90                             2U
+#define PP_ROTATION_HOR_FLIP                            3U
+#define PP_ROTATION_VER_FLIP                            4U
+#define PP_ROTATION_180                                 5U
+
+#define memzero(x)	memset(&(x), 0, sizeof (x));
+
+typedef enum {
+	eV4L2_BUF_DEQUEUE,	
+	eV4L2_BUF_INQUEUE
+}E_V4L2_BUF_STATUS;
+
+/* video decoder related parameters */
+struct video {
+	int fd;
+
+	/* Output queue related for encoded bitstream*/ 
+	int out_buf_cnt;
+	int out_buf_size;
+	int out_buf_off[MAX_OUT_BUF];
+	char *out_buf_addr[MAX_OUT_BUF];
+	E_V4L2_BUF_STATUS out_buf_flag[MAX_OUT_BUF];
+
+	/* Capture queue related for decoded buffer*/
+	int cap_w;
+	int cap_h;
+	int cap_crop_w;
+	int cap_crop_h;
+	int cap_crop_left;
+	int cap_crop_top;
+	int cap_buf_cnt;
+	int cap_buf_cnt_min;
+	int cap_buf_num_planes;
+	int cap_buf_planes_size[MAX_CAP_BUF][MAX_PLANES]; //each plane (for example: YUV422P planes)size
+	int cap_buf_off[MAX_CAP_BUF][MAX_PLANES];
+	char *cap_buf_addr[MAX_CAP_BUF][MAX_PLANES];
+//	uint32_t cap_buf_dma_addr[MAX_CAP_BUF][MAX_PLANES];
+	E_V4L2_BUF_STATUS cap_buf_flag[MAX_CAP_BUF];
+	int cap_buf_queued;
+	unsigned long total_captured;
+};
+
+// video decode post processing
+struct video_fb_info {
+	void  *frame_buf_paddr;          /* physical address of frame buffer           */
+	int   frame_buf_size;
+	int   frame_buf_w;               /* width of frame buffer width               */
+	int   frame_buf_h;               /* height of frame buffer                    */
+	int	  direct_fb_out;			 /* directly frame buffer output mode          */
+	unsigned int frame_buf_no;       /* frame buffer number for direct fb output */
+};
+
+int vc8000_v4l2_open(struct video *psVideo);
+void vc8000_v4l2_close(struct video *psVideo);
+
+/*setup vc8000 v4l2 output(bitstream) plane
+codec:
+	V4L2_PIX_FMT_H264
+	V4L2_PIX_FMT_JPEG
+*/
+
+int vc8000_v4l2_setup_output(
+	struct video *psVideo,
+	unsigned long codec,
+	unsigned int size,
+	int count
+);
+
+/* 
+Setup capture(decoded) plane
+pixel_format: 
+	V4L2_PIX_FMT_NV12
+	V4L2_PIX_FMT_ARGB32
+	V4L2_PIX_FMT_RGB565
+*/
+
+int vc8000_v4l2_setup_capture(
+	struct video *psVideo,
+	int pixel_format,
+	int extra_buf,
+	int w,
+	int h
+);
+
+//Release output and capture plane
+void vc8000_v4l2_release_output(
+	struct video *psVideo
+);
+
+void vc8000_v4l2_release_capture(
+	struct video *psVideo
+);
+
+//queue output buffer
+int vc8000_v4l2_queue_output(
+	struct video *psVideo,
+	int n,
+	int length
+);
+
+//queue capture buffer
+int vc8000_v4l2_queue_capture(
+	struct video *psVideo,
+	int n
+);
+
+//dequeue output buffer
+int vc8000_v4l2_dequeue_output(
+	struct video *psVideo,
+	int *n
+);
+
+//dequeue capture buffer
+int vc8000_v4l2_dequeue_capture(
+	struct video *psVideo,
+	int *n, 
+	int *finished,
+	unsigned int *bytesused
+);
+
+//set output/capture stream on/off
+int vc8000_v4l2_stream(
+	struct video *psVideo,
+	enum v4l2_buf_type type, 
+	int status
+);
+
+int vc8000_v4l2_stop_capture(
+	struct video *psVideo
+);
+
+int vc8000_v4l2_stop_output(
+	struct video *psVideo
+);
+
+//stop vc8000 v4l2 decode all plane
+int vc8000_v4l2_stop(
+	struct video *psVideo
+);
+
+//Prepare JPEG decompress
+int vc8000_jpeg_prepare_decompress(
+	struct video *psVideo,
+	uint32_t u32ImageWidth,
+	uint32_t u32ImageHeight,
+	uint32_t u32OutputWidth,
+	uint32_t u32OutputHeight,
+	bool bDirectFBOut,
+	struct video_fb_info *psFBInfo,
+	uint32_t u32ImgFBPosX,
+	uint32_t u32ImgFBPosY,
+	int i32RotOP,
+	int pixel_format
+);
+
+//Get JPEG decompress bitstream buffer
+int vc8000_jpeg_get_bitstream_buffer(
+	struct video *psVideo,
+	char **ppchBufferAddr
+);
+
+//Inqueue bitstream and trigger decompress
+int vc8000_jpeg_inqueue_bitstream_buffer(
+	struct video *psVideo,
+	char *pchBufferAddr,
+	uint32_t u32StreamLen
+);
+
+//Wait JPEG decode done
+int vc8000_jpeg_poll_decode_done(
+        struct video *psVideo,
+        int *p_cap_index
+);
+
+//Release JPEG decompress
+int vc8000_jpeg_release_decompress(
+        struct video *psVideo
+);
+
+#endif
